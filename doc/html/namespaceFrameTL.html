<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FrameTL Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>FrameTL Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>PolySolBiharmonic</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SimpleTest</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SimpleTestRHS</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SimpleTestGradient</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Biharmonic1D__Solution.html">Biharmonic1D_Solution</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Biharmonic1D__RHS__Integrand.html">Biharmonic1D_RHS_Integrand</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Biharmonic1D__RHS.html">Biharmonic1D_RHS</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1BiharmonicEquation.html">BiharmonicEquation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>CDD1Parameters</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Singularity1D__RHS__2.html">Singularity1D_RHS_2</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Singularity1D__2.html">Singularity1D_2</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1EllipticEquation.html">EllipticEquation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1EvaluateFrame.html">EvaluateFrame</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>EvaluateFrame&lt; IBASIS, 1, 1 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>EvaluateFrame&lt; IBASIS, 2, 2 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFrameTL_1_1Coefficient.html">Coefficient</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Functional.html">Functional</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Index1D.html">Index1D</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Singularity1D__2__prime.html">Singularity1D_2_prime</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Poisson__Solution__Ring.html">Poisson_Solution_Ring</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Poisson__RHS__Ring.html">Poisson_RHS_Ring</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1Poisson__SolutionGradient__Ring.html">Poisson_SolutionGradient_Ring</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1SimpleBiharmonicEquation.html">SimpleBiharmonicEquation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameTL_1_1SimpleEllipticEquation.html">SimpleEllipticEquation</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5f7cd84df62cbac0d03d55a63858d138"></a><!-- doxytag: member="FrameTL::H_1_error_interval" ref="5f7cd84df62cbac0d03d55a63858d138" args="(const AggregatedFrame&lt; IBASIS, DIM, DIM &gt; &amp;frame, const InfiniteVector&lt; double, typename AggregatedFrame&lt; IBASIS, DIM, DIM &gt;::Index &gt; &amp;coeffs, const Function&lt; 1 &gt; &amp;f)" -->
template&lt;class IBASIS, int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>H_1_error_interval</b> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM, DIM &gt; &amp;frame, const InfiniteVector&lt; double, typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM, DIM &gt;::Index &gt; &amp;coeffs, const Function&lt; 1 &gt; &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1b900f7d22f4b32129f53074030c4d85"></a><!-- doxytag: member="FrameTL::error_H_scale_interval" ref="1b900f7d22f4b32129f53074030c4d85" args="(const int order, const AggregatedFrame&lt; IBASIS, DIM, DIM &gt; &amp;frame, const InfiniteVector&lt; double, typename AggregatedFrame&lt; IBASIS, DIM, DIM &gt;::Index &gt; &amp;coeffs, const Function&lt; 1 &gt; &amp;f)" -->
template&lt;class IBASIS, int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>error_H_scale_interval</b> (const int order, const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM, DIM &gt; &amp;frame, const InfiniteVector&lt; double, typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM, DIM &gt;::Index &gt; &amp;coeffs, const Function&lt; 1 &gt; &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2c2397a9802a34ffc082c4de792c808d"></a><!-- doxytag: member="FrameTL::thin_out_ring" ref="2c2397a9802a34ffc082c4de792c808d" args="(PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_sparse, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_very_sparse)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>thin_out_ring</b> (PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_sparse, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_very_sparse)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9e04ddf27423214b1a0ffa4060ce6224"></a><!-- doxytag: member="FrameTL::thin_out" ref="9e04ddf27423214b1a0ffa4060ce6224" args="(PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_sparse, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_very_sparse)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>thin_out</b> (PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_sparse, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_very_sparse)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4c6e64c8471915c044140f434fd54372"></a><!-- doxytag: member="FrameTL::remove_i" ref="4c6e64c8471915c044140f434fd54372" args="(const int i, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>remove_i</b> (const int i, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#fae0f5be715e2324d15ca01a18665855">AddSchw</a> (const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptive additive Schwarz wavelet frame algorithm from PhD thesis Werner 2009.  <a href="#fae0f5be715e2324d15ca01a18665855"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9af3764c23011a0c0d4ceb60995cae01"></a><!-- doxytag: member="FrameTL::split" ref="9af3764c23011a0c0d4ceb60995cae01" args="(PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u1, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u2)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>split</b> (PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u1, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#a6fc7f7f5f218c3dc3e34081b4e7464d">MultSchw</a> (const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptive multiplicative Schwarz wavelet frame algorithm from Stevenson, Werner 2009.  <a href="#a6fc7f7f5f218c3dc3e34081b4e7464d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3ee8bc795a39cbc2a1084ff7f9735da1"></a><!-- doxytag: member="FrameTL::adaptive_multiplicative_Schwarz_SOLVE" ref="3ee8bc795a39cbc2a1084ff7f9735da1" args="(const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>adaptive_multiplicative_Schwarz_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c081a164d56c41204ca6981f3eca36a7"></a><!-- doxytag: member="FrameTL::GALERKIN" ref="c081a164d56c41204ca6981f3eca36a7" args="(PROBLEM &amp;P, const set&lt; typename PROBLEM::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;rhs, Vector&lt; double &gt; &amp;u)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>GALERKIN</b> (PROBLEM &amp;P, const set&lt; typename PROBLEM::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;rhs, Vector&lt; double &gt; &amp;u)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a4b0c696b6cd000adf04b5fb5c484a04"></a><!-- doxytag: member="FrameTL::additive_Schwarz_SOLVE" ref="a4b0c696b6cd000adf04b5fb5c484a04" args="(PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>additive_Schwarz_SOLVE</b> (PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="affbbbc817346e4a1c801ff4f2f38f5d"></a><!-- doxytag: member="FrameTL::addtive_Schwarz_SOLVE" ref="affbbbc817346e4a1c801ff4f2f38f5d" args="(PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>addtive_Schwarz_SOLVE</b> (PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6ea4f0fd019efd168c07f7dd5a6aca4c"></a><!-- doxytag: member="FrameTL::additive_Schwarz_SD_SOLVE" ref="6ea4f0fd019efd168c07f7dd5a6aca4c" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>additive_Schwarz_SD_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0f8abfca6433dce3a533205aca27803c"></a><!-- doxytag: member="FrameTL::addtive_Schwarz_SD_SOLVE" ref="0f8abfca6433dce3a533205aca27803c" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>addtive_Schwarz_SD_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#d92777b6b7c3d1dc873761d9280ec994">precompute_supports_simple</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; *frame, Array1D&lt; typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Support &gt; &amp;all_patch_supports)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#218a9a8d5b69562375139a49043fce0b">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#8a92efb82d1634c8cf05737d5164b731">CDD1_LOCAL_SOLVE</a> (const PROBLEM &amp;P, const int patch, const double epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;guess, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v_k, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The routine ALGORITHMc from [BB+], with a given initial guess for u_epsilon.  <a href="#8a92efb82d1634c8cf05737d5164b731"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f1d8dd5608d705fbf2563b8a266d14a9"></a><!-- doxytag: member="FrameTL::CDD1_LOCAL_SOLVE" ref="f1d8dd5608d705fbf2563b8a266d14a9" args="(const PROBLEM &amp;P, const int patch, const double epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;guess, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v_k, const double c1, const double c2, const int jmax, const CompressionStrategy strategy)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#f1d8dd5608d705fbf2563b8a266d14a9">CDD1_LOCAL_SOLVE</a> (const PROBLEM &amp;P, const int patch, const double epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;guess, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v_k, const double c1, const double c2, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The routine ALGORITHMc from [BB+], with a given initial guess for u_epsilon and for the parameters c1,c2. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#d25b2eb9873b17224cdc0ddc9b0d04b1">NPROG</a> (const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double delta, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v_hat, set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda_hat, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r_hat, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_Lambda_k, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NPROG.  <a href="#d25b2eb9873b17224cdc0ddc9b0d04b1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#5338ae7f2ce93a8449560cc020fa212a">GALERKIN</a> (const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double delta, const double eta, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_bar, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GALERKIN.  <a href="#5338ae7f2ce93a8449560cc020fa212a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#f3d9112d64f468a664317686725617bd">NGROW</a> (const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_bar, const double xi1, const double xi2, set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda_tilde, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NGROW.  <a href="#f3d9112d64f468a664317686725617bd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#cd7462527bff134a7c142ee0471d6ab2">INRESIDUAL</a> (const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double eta1, const double eta2, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">INRESIDUAL.  <a href="#cd7462527bff134a7c142ee0471d6ab2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#e86daf5e125e66504844e002ba3dc4b5">NRESIDUAL</a> (const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double eta1, const double eta2, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r, set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda_tilde, const int jmax, const CompressionStrategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRESIDUAL.  <a href="#e86daf5e125e66504844e002ba3dc4b5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="391c8708bf59582ba636bfb5a394d2b7"></a><!-- doxytag: member="FrameTL::cg_SOLVE" ref="391c8708bf59582ba636bfb5a394d2b7" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>cg_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#addaaee53d308a6093a25ed95f86cc85">error_H_scale_interval</a> (const int order, const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, 1, 1 &gt; &amp;frame, const InfiniteVector&lt; double, typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, 1, 1 &gt;::Index &gt; &amp;coeffs, const Function&lt; 1 &gt; &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function computes the <img class="formulaInl" alt="$L_2$" src="form_34.png">-norm or <img class="formulaInl" alt="$H^1$" src="form_35.png">-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the unit interval.  <a href="#addaaee53d308a6093a25ed95f86cc85"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#54aa679fc30456b9ca268846c1926992">error_H_scale_Lshaped</a> (const int order, const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, 2, 2 &gt; &amp;frame, const InfiniteVector&lt; double, typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, 2, 2 &gt;::Index &gt; &amp;coeffs, const Function&lt; 2 &gt; &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function computes the <img class="formulaInl" alt="$L_2$" src="form_34.png">-norm or <img class="formulaInl" alt="$H^1$" src="form_35.png">-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the L-shaped domain <img class="formulaInl" alt="$[-1,1]^2 \ [0,1)^2$" src="form_36.png">.  <a href="#54aa679fc30456b9ca268846c1926992"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#3ce808a3f26fc1938139488a730e994d">H_1_semi_norm_Lshaped</a> (const Function&lt; 2 &gt; &amp;gradient)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an approximation to the <img class="formulaInl" alt="$H^1$" src="form_35.png">-norm of a function in the L-shaped domain <img class="formulaInl" alt="$[-1,1]^2 \ [0,1)^2$" src="form_36.png">.  <a href="#3ce808a3f26fc1938139488a730e994d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#6f69a38cdff114000317fd48750b471b">first_generator</a> (const FRAME *frame, const int j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#a6650ac9337756c12f5022699c50cc28">last_generator</a> (const FRAME *frame, const int j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#ad2c37c6767c23fca5c2c3e1563680a5">first_wavelet</a> (const FRAME *frame, const int j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#7c29f890e91e2cd966b9ac6b773277cf">last_wavelet</a> (const FRAME *frame, const int j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#80cab15b10b2b3bff9e29f51409f7ce7">first_generator_num</a> (const FRAME *frame)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#0544af1a279910dc8bcdb9b542df3166">last_generator_num</a> (const FRAME *frame)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#d2a45d507a64c17ff1cf1edeb7afcd8e">first_wavelet_num</a> (const FRAME *frame, const int j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#98345f161b05ac9604fbd9070da0bba7">last_wavelet_num</a> (const FRAME *frame, const int j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#4f787a15e5a101207d222e0a799a7e5d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="80a56eff444cfd2880b83403ab09e808"></a><!-- doxytag: member="FrameTL::to_array" ref="80a56eff444cfd2880b83403ab09e808" args="(const InfiniteVector&lt; double, INDEX &gt; &amp;ivec, Coefficient *coeff_array)" -->
template&lt;class INDEX&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>to_array</b> (const InfiniteVector&lt; double, INDEX &gt; &amp;ivec, <a class="el" href="structFrameTL_1_1Coefficient.html">Coefficient</a> *coeff_array)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3b946e677f70c5b04b3cec8feeadc20e"></a><!-- doxytag: member="FrameTL::array_to_map" ref="3b946e677f70c5b04b3cec8feeadc20e" args="(const Coefficient *coeff_array, const FRAME *frame, InfiniteVector&lt; double, INDEX &gt; &amp;ivec, const int count)" -->
template&lt;class INDEX, class FRAME&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>array_to_map</b> (const <a class="el" href="structFrameTL_1_1Coefficient.html">Coefficient</a> *coeff_array, const FRAME *frame, InfiniteVector&lt; double, INDEX &gt; &amp;ivec, const int count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="26ebfba3c24541d4c0b1e7591fbb6d47"></a><!-- doxytag: member="FrameTL::eq" ref="26ebfba3c24541d4c0b1e7591fbb6d47" args="(const double x, const double y)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>eq</b> (const double x, const double y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bb8df9a03d57ebc0a19a9d58fddf19b"></a><!-- doxytag: member="FrameTL::lt" ref="6bb8df9a03d57ebc0a19a9d58fddf19b" args="(const double x, const double y)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>lt</b> (const double x, const double y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8004ad60ec83531e6c45e0e45d09d73b"></a><!-- doxytag: member="FrameTL::gt" ref="8004ad60ec83531e6c45e0e45d09d73b" args="(const double x, const double y)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>gt</b> (const double x, const double y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="524bc935ed1e0794c223e364ce0dbc96"></a><!-- doxytag: member="FrameTL::leq" ref="524bc935ed1e0794c223e364ce0dbc96" args="(const double x, const double y)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>leq</b> (const double x, const double y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unsigned short int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#d4045e5ba1e89e5fbdd9084024f16ae0">pos_wrt_line</a> (const Point&lt; DIM &gt; &amp;p, const Point&lt; DIM &gt; &amp;p1, const Point&lt; DIM &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#0699f5e7931ab40bf346b17e6c3bde01">in_support</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const Point&lt; DIM_m &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="42d9dd29c91fe172a30736eb38ee21e9"></a><!-- doxytag: member="FrameTL::in_support" ref="42d9dd29c91fe172a30736eb38ee21e9" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const Point&lt; DIM_m &gt; &amp;p)" -->
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>in_support</b> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const Point&lt; DIM_m &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#6d6670ec9613c9cf6ac3511a4b623429">intersect_supports</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_mu)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#8008f4b3d0a7bb7acab2b74a29d60222">intersect_supports_simple</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#0f4762cff5b194a929e2eadddbfd0d71">quadrangles_intersect</a> (FixedArray1D&lt; Point&lt; DIM &gt;, 4 &gt; poly1, FixedArray1D&lt; Point&lt; DIM &gt;, 4 &gt; poly2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#02c30f3ec04242a2445af8e588bae6b2">intersect_supports_1D</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const <a class="el" href="classFrameTL_1_1Index1D.html">Index1D</a>&lt; IBASIS &gt; &amp;lambda, const <a class="el" href="classFrameTL_1_1Index1D.html">Index1D</a>&lt; IBASIS &gt; &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_mu, const int dir, Array1D&lt; double &gt; &amp;supp_intersect)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#5aeecded043a910b0dae7228883304b3">intersect_supports</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_mu, FixedArray1D&lt; Array1D&lt; double &gt;, DIM_d &gt; &amp;supp_intersect)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#1823fb7effb657b388e652efbef319b3">intersecting_wavelets</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const int j, const bool generators, std::list&lt; typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;intersecting)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#0005c53dfff8661290582ea77b5ebcff">intersecting_wavelets</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const int p, const std::set&lt; typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;Lambda, std::list&lt; typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;intersecting)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#e57f8b33a1d5167ca7a23c7762e9ad1a">intersecting_wavelets_on_patch</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const int p, const int j, const bool generators, std::list&lt; typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;intersecting)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#27f6cca23b933ff76a0597a62f5dd870">intersect_singular_support</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#179a53ae796b31d73b591456b7e8240e">edgesIntersect</a> (const Point&lt; DIM &gt; &amp;A, const Point&lt; DIM &gt; &amp;B, const Point&lt; DIM &gt; &amp;C, const Point&lt; DIM &gt; &amp;D)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#0b6d3a80be9f0dd032527c3c17ce3f62">intersect_supports</a> (const <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a>&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM, class VALUE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const Point&lt; DIM &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#110b0b11455f5d648c2cb3a7866f3900">apply</a> (const Matrix&lt; VALUE &gt; &amp;M, const Point&lt; DIM &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM, class VALUE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#7f2d7a0a9f79b15e8d82ff8363d06bb5">apply</a> (const Matrix&lt; VALUE &gt; &amp;M, const Point&lt; DIM &gt; &amp;p, Point&lt; DIM &gt; &amp;res)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Point&lt; DIM &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#fd9af4210f87f330a600bdba74ca3f6d">add</a> (const Point&lt; DIM &gt; &amp;p, const Vector&lt; double &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Point&lt; DIM &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#ab03f9658bfef63434301affb3b5803a">sub</a> (const Point&lt; DIM &gt; &amp;p, const Vector&lt; double &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#b442ddca04900a00608a3963348b15bb">inner_prod</a> (const Point&lt; DIM &gt; &amp;p1, const Point&lt; DIM &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#6fd34de92145c0f42b41f9b36a379e9f">norm2</a> (Point&lt; DIM &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d1c8aa47dd1f4024c97146dd88d48a72"></a><!-- doxytag: member="FrameTL::swap" ref="d1c8aa47dd1f4024c97146dd88d48a72" args="(const Point&lt; DIM &gt; &amp;p1, const Point&lt; DIM &gt; &amp;p2)" -->
template&lt;unsigned int DIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (const Point&lt; DIM &gt; &amp;p1, const Point&lt; DIM &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f10c19e668efd734a36e982750184b11"></a><!-- doxytag: member="FrameTL::REDUCE_REDUNDANCY" ref="f10c19e668efd734a36e982750184b11" args="(PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_sparse)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>REDUCE_REDUNDANCY</b> (PROBLEM &amp;P, const int i, const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_sparse)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6d0fc5d89ccc66faf29046d3bcfe3475"></a><!-- doxytag: member="FrameTL::intersect_line1" ref="6d0fc5d89ccc66faf29046d3bcfe3475" args="(PROBLEM &amp;P, const typename PROBLEM::Index &amp;lambda)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>intersect_line1</b> (PROBLEM &amp;P, const typename PROBLEM::Index &amp;lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7ba0009c3b5505a7a9a720663d21526d"></a><!-- doxytag: member="FrameTL::intersect_line2" ref="7ba0009c3b5505a7a9a720663d21526d" args="(PROBLEM &amp;P, const typename PROBLEM::Index &amp;lambda)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>intersect_line2</b> (PROBLEM &amp;P, const typename PROBLEM::Index &amp;lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="30434f281b420f817ba55886c5b1bd82"></a><!-- doxytag: member="FrameTL::contact_with_patch2" ref="30434f281b420f817ba55886c5b1bd82" args="(PROBLEM &amp;P, const typename PROBLEM::Index &amp;lambda)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>contact_with_patch2</b> (PROBLEM &amp;P, const typename PROBLEM::Index &amp;lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8d41aa77fa6da618ad97ddc75c920a55"></a><!-- doxytag: member="FrameTL::multiplicative_Schwarz_SOLVE" ref="8d41aa77fa6da618ad97ddc75c920a55" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon_0, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon_1, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>multiplicative_Schwarz_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon_0, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon_1, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#010a7b97f26561b6923f285c1cbb8d02">setup_coefficient_datatype</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#868f995657a7f68345fe24340658282e">send_to_Master</a> (const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#3ea47092508598512ecc54955117a16f">receive_all_parts</a> (const PROBLEM &amp;P, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#99afa22a98a5b20d8326b2983bb19088">broadcast_vec_from_Master</a> (const PROBLEM &amp;P, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#5b01ba18f76ca06fb77d8cbca90492e8">broadcast_double_from_Master</a> (double &amp;d)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bacf8c8fd02179e596a29355d939ec7c"></a><!-- doxytag: member="FrameTL::richardson_SOLVE" ref="bacf8c8fd02179e596a29355d939ec7c" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>richardson_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1111c8e69e372f889361af29dad3c8dd"></a><!-- doxytag: member="FrameTL::for" ref="1111c8e69e372f889361af29dad3c8dd" args="(int i=0;i&lt; P.basis().n_p();i++)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>for</b> (int i=0;i&lt; P.basis().n_p();i++)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1a05babec2a9b0c713764d9ba15e2048"></a><!-- doxytag: member="FrameTL::richardson_SOLVE_CDD2" ref="1a05babec2a9b0c713764d9ba15e2048" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>richardson_SOLVE_CDD2</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#c04ff1f80c162c3369928a2b45402beb">simplified_steepest_descent_SOLVE</a> (const PROBLEM &amp;problem, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon, const int jmax)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFrameTL.html#b98b858d0561768f9494ac7f962a6857">steepest_descent_SOLVE</a> (const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptive steepest descent wavelet frame algorithm from Dahlke, Fornasier, Raasch, Stevenson, Werner 2007.  <a href="#b98b858d0561768f9494ac7f962a6857"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bb9619e1ba041c247f306eb45f1d0e90"></a><!-- doxytag: member="FrameTL::steepest_descent1_SOLVE" ref="bb9619e1ba041c247f306eb45f1d0e90" args="(const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon, int jmax, InfiniteVector&lt; double, typename PROBLEM::Index &gt; rhs)" -->
template&lt;class PROBLEM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>steepest_descent1_SOLVE</b> (const PROBLEM &amp;P, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon, int jmax, InfiniteVector&lt; double, typename PROBLEM::Index &gt; rhs)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed8caef1981377375248b70b9df6b085"></a><!-- doxytag: member="FrameTL::coefficient_datatype" ref="ed8caef1981377375248b70b9df6b085" args="" -->
MPI_Datatype&nbsp;</td><td class="memItemRight" valign="bottom"><b>coefficient_datatype</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ecdb4ced7f7d4e5fde0db90a76dd3741"></a><!-- doxytag: member="FrameTL::approximations" ref="ecdb4ced7f7d4e5fde0db90a76dd3741" args="[P.basis().n_p()]" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>approximations</b> [P.basis().n_p()] = u_epsilon</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace <a class="el" href="namespaceFrameTL.html">FrameTL</a>. <hr><h2>Function Documentation</h2>
<a class="anchor" name="fd9af4210f87f330a600bdba74ca3f6d"></a><!-- doxytag: member="FrameTL::add" ref="fd9af4210f87f330a600bdba74ca3f6d" args="(const Point&lt; DIM &gt; &amp;p, const Vector&lt; double &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Point&lt;DIM&gt; FrameTL::add           </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add Point p, viewed as vector, to Vector b 
</div>
</div><p>
<a class="anchor" name="fae0f5be715e2324d15ca01a18665855"></a><!-- doxytag: member="FrameTL::AddSchw" ref="fae0f5be715e2324d15ca01a18665855" args="(const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::AddSchw           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>approximations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adaptive additive Schwarz wavelet frame algorithm from PhD thesis Werner 2009. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The cached discrete problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The target <img class="formulaInl" alt="$\ell_2$" src="form_0.png">-accuracy of the algorithm. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>approximations</em>&nbsp;</td><td>An array of length number of patches+1. We return in this array the local discrete approximations on each patch.} The last entry contains the final global discrete approximation at termination. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f2d7a0a9f79b15e8d82ff8363d06bb5"></a><!-- doxytag: member="FrameTL::apply" ref="7f2d7a0a9f79b15e8d82ff8363d06bb5" args="(const Matrix&lt; VALUE &gt; &amp;M, const Point&lt; DIM &gt; &amp;p, Point&lt; DIM &gt; &amp;res)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM, class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::apply           </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
apply matrix M to point p (p viewed as a vector) 
</div>
</div><p>
<a class="anchor" name="110b0b11455f5d648c2cb3a7866f3900"></a><!-- doxytag: member="FrameTL::apply" ref="110b0b11455f5d648c2cb3a7866f3900" args="(const Matrix&lt; VALUE &gt; &amp;M, const Point&lt; DIM &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM, class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Point&lt;DIM&gt; FrameTL::apply           </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
apply matrix M to point p (p viewed as a vector) 
</div>
</div><p>
<a class="anchor" name="5b01ba18f76ca06fb77d8cbca90492e8"></a><!-- doxytag: member="FrameTL::broadcast_double_from_Master" ref="5b01ba18f76ca06fb77d8cbca90492e8" args="(double &amp;d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::broadcast_double_from_Master           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The master processor sends a double to all other (slave) processors. 
</div>
</div><p>
<a class="anchor" name="99afa22a98a5b20d8326b2983bb19088"></a><!-- doxytag: member="FrameTL::broadcast_vec_from_Master" ref="99afa22a98a5b20d8326b2983bb19088" args="(const PROBLEM &amp;P, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::broadcast_vec_from_Master           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The master processor sends an InfiniteVector&lt;double, typename PROBLEM::Index&gt; to all other (slave) processors. 
</div>
</div><p>
<a class="anchor" name="8a92efb82d1634c8cf05737d5164b731"></a><!-- doxytag: member="FrameTL::CDD1_LOCAL_SOLVE" ref="8a92efb82d1634c8cf05737d5164b731" args="(const PROBLEM &amp;P, const int patch, const double epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;guess, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_epsilon, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v_k, const int jmax, const CompressionStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::CDD1_LOCAL_SOLVE           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u_epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompressionStrategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The routine ALGORITHMc from [BB+], with a given initial guess for u_epsilon. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The global discrete (cached) problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>The patch on which the local auxiliary problem has to be solved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The target accuracy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gues</em>&nbsp;</td><td>The initial gues from which the adaptive Galerkin scheme is started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u_epsilon</em>&nbsp;</td><td>The final approximation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_k</em>&nbsp;</td><td>For the case of the multiplicative Schwarz method a la Stevenson/Werner 2009, v_k have to be the coefficients u_k^{(j)}, j i f from eq. (6.1.23) in Manuel's PhD thesis. In the additive case, v_k are the frame coeffients of the function in the first argument of the bilinear form a(.,.) in the right-hand side of the local problem in algorithm AddSchw on page 165 of Manuel's thesis. param jmax The maximal alevel of resolution. param strategy The compression strategy (the way to create the matrix A_j from Definition 4.2 in Manuels PhD thesis).} </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="179a53ae796b31d73b591456b7e8240e"></a><!-- doxytag: member="FrameTL::edgesIntersect" ref="179a53ae796b31d73b591456b7e8240e" args="(const Point&lt; DIM &gt; &amp;A, const Point&lt; DIM &gt; &amp;B, const Point&lt; DIM &gt; &amp;C, const Point&lt; DIM &gt; &amp;D)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int FrameTL::edgesIntersect           </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>D</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine tests whether the line segments defined by the points A and B as well as C and D intersect. 0 = no intersection 1 = infinitely many intersection points 2 = single intersection point, but at least one knot involved 3 = single intersection point situated in the inner of both line segments 
</div>
</div><p>
<a class="anchor" name="addaaee53d308a6093a25ed95f86cc85"></a><!-- doxytag: member="FrameTL::error_H_scale_interval" ref="addaaee53d308a6093a25ed95f86cc85" args="(const int order, const AggregatedFrame&lt; IBASIS, 1, 1 &gt; &amp;frame, const InfiniteVector&lt; double, typename AggregatedFrame&lt; IBASIS, 1, 1 &gt;::Index &gt; &amp;coeffs, const Function&lt; 1 &gt; &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double FrameTL::error_H_scale_interval           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, 1, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename AggregatedFrame&lt; IBASIS, 1, 1 &gt;::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function&lt; 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function computes the <img class="formulaInl" alt="$L_2$" src="form_34.png">-norm or <img class="formulaInl" alt="$H^1$" src="form_35.png">-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the unit interval. 
<p>
The last parameter of this routine has to be the function, or, in case of the <img class="formulaInl" alt="$H^1$" src="form_35.png">-seminorm, it has to be the derivative of the function. 
</div>
</div><p>
<a class="anchor" name="54aa679fc30456b9ca268846c1926992"></a><!-- doxytag: member="FrameTL::error_H_scale_Lshaped" ref="54aa679fc30456b9ca268846c1926992" args="(const int order, const AggregatedFrame&lt; IBASIS, 2, 2 &gt; &amp;frame, const InfiniteVector&lt; double, typename AggregatedFrame&lt; IBASIS, 2, 2 &gt;::Index &gt; &amp;coeffs, const Function&lt; 2 &gt; &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double FrameTL::error_H_scale_Lshaped           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, 2, 2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename AggregatedFrame&lt; IBASIS, 2, 2 &gt;::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function&lt; 2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function computes the <img class="formulaInl" alt="$L_2$" src="form_34.png">-norm or <img class="formulaInl" alt="$H^1$" src="form_35.png">-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the L-shaped domain <img class="formulaInl" alt="$[-1,1]^2 \ [0,1)^2$" src="form_36.png">. 
<p>
The last parameter of this routine has to be the function, or, in case of the <img class="formulaInl" alt="$H^1$" src="form_35.png">-seminorm, it has to be the gradient of the function. 
</div>
</div><p>
<a class="anchor" name="6f69a38cdff114000317fd48750b471b"></a><!-- doxytag: member="FrameTL::first_generator" ref="6f69a38cdff114000317fd48750b471b" args="(const FRAME *frame, const int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt; FrameTL::first_generator           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of first generator on level <img class="formulaInl" alt="$j \geq j_0$" src="form_4.png">. 
</div>
</div><p>
<a class="anchor" name="80cab15b10b2b3bff9e29f51409f7ce7"></a><!-- doxytag: member="FrameTL::first_generator_num" ref="80cab15b10b2b3bff9e29f51409f7ce7" args="(const FRAME *frame)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int FrameTL::first_generator_num           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of first generator on level <img class="formulaInl" alt="$j_0$" src="form_5.png">. 
</div>
</div><p>
<a class="anchor" name="ad2c37c6767c23fca5c2c3e1563680a5"></a><!-- doxytag: member="FrameTL::first_wavelet" ref="ad2c37c6767c23fca5c2c3e1563680a5" args="(const FRAME *frame, const int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt; FrameTL::first_wavelet           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of first wavelet on level <img class="formulaInl" alt="$j \geq j_0$" src="form_4.png">. 
</div>
</div><p>
<a class="anchor" name="d2a45d507a64c17ff1cf1edeb7afcd8e"></a><!-- doxytag: member="FrameTL::first_wavelet_num" ref="d2a45d507a64c17ff1cf1edeb7afcd8e" args="(const FRAME *frame, const int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int FrameTL::first_wavelet_num           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of first wavelet on level <img class="formulaInl" alt="$j \geq j0$" src="form_37.png">. 
</div>
</div><p>
<a class="anchor" name="5338ae7f2ce93a8449560cc020fa212a"></a><!-- doxytag: member="FrameTL::GALERKIN" ref="5338ae7f2ce93a8449560cc020fa212a" args="(const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double delta, const double eta, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_bar, const int jmax, const CompressionStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::GALERKIN           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CDD1Parameters &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u_bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompressionStrategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GALERKIN. 
<p>
Given an approximation v to the exact Galerkin solution u_Lambda of Au = F w.r.t. the index set Lambda, such that ||u_Lambda-v||_2 &lt;= delta, and a target accuracy eta, compute an approximation u_bar to u_Lambda which is supported on Lambda and satisfies ||u_bar-u_Lambda||_2 &lt;= eta. 
</div>
</div><p>
<a class="anchor" name="3ce808a3f26fc1938139488a730e994d"></a><!-- doxytag: member="FrameTL::H_1_semi_norm_Lshaped" ref="3ce808a3f26fc1938139488a730e994d" args="(const Function&lt; 2 &gt; &amp;gradient)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FrameTL::H_1_semi_norm_Lshaped           </td>
          <td>(</td>
          <td class="paramtype">const Function&lt; 2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gradient</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes an approximation to the <img class="formulaInl" alt="$H^1$" src="form_35.png">-norm of a function in the L-shaped domain <img class="formulaInl" alt="$[-1,1]^2 \ [0,1)^2$" src="form_36.png">. 
<p>
The parameter gradient is assumed to be the gradient of the function. 
</div>
</div><p>
<a class="anchor" name="0699f5e7931ab40bf346b17e6c3bde01"></a><!-- doxytag: member="FrameTL::in_support" ref="0699f5e7931ab40bf346b17e6c3bde01" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const Point&lt; DIM_m &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::in_support           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether Point 'p' lies in the support of the wavelet frame element <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png">. 
</div>
</div><p>
<a class="anchor" name="b442ddca04900a00608a3963348b15bb"></a><!-- doxytag: member="FrameTL::inner_prod" ref="b442ddca04900a00608a3963348b15bb" args="(const Point&lt; DIM &gt; &amp;p1, const Point&lt; DIM &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double FrameTL::inner_prod           </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether p lies left of right of or on the line specified by the Points p1 and p2. This line is oriented by the vector starting in p1 and ending in p2. returning 0 means RIGHT OF LINE returning 1 means LEFT OF LINE returning 2 means ON LINE<p>
computes l_2 inner product will be placed in class Point in the future or replaced by appropriate function in class tensor 
</div>
</div><p>
<a class="anchor" name="cd7462527bff134a7c142ee0471d6ab2"></a><!-- doxytag: member="FrameTL::INRESIDUAL" ref="cd7462527bff134a7c142ee0471d6ab2" args="(const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double eta1, const double eta2, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r, const int jmax, const CompressionStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::INRESIDUAL           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CDD1Parameters &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompressionStrategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
INRESIDUAL. 
<p>
Given an index set Lambda, an approximation v to the exact Galerkin solution u_Lambda of Au = F, calculate an approximate INternal residual r, such that ||r - (A_Lambda v - P_Lambda f)||_2 &lt;= eta_1 + eta_2 
</div>
</div><p>
<a class="anchor" name="27f6cca23b933ff76a0597a62f5dd870"></a><!-- doxytag: member="FrameTL::intersect_singular_support" ref="27f6cca23b933ff76a0597a62f5dd870" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::intersect_singular_support           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>nu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decide whether the support of a given generator/wavelet <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png"> intersects the singular support of another generator/wavelet <img class="formulaInl" alt="$\psi_\nu$" src="form_39.png">. 
</div>
</div><p>
<a class="anchor" name="0b6d3a80be9f0dd032527c3c17ce3f62"></a><!-- doxytag: member="FrameTL::intersect_supports" ref="0b6d3a80be9f0dd032527c3c17ce3f62" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::intersect_supports           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether the support of the wavelet frame elements intersect. 
</div>
</div><p>
<a class="anchor" name="5aeecded043a910b0dae7228883304b3"></a><!-- doxytag: member="FrameTL::intersect_supports" ref="5aeecded043a910b0dae7228883304b3" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_mu, FixedArray1D&lt; Array1D&lt; double &gt;, DIM_d &gt; &amp;supp_intersect)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::intersect_supports           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FixedArray1D&lt; Array1D&lt; double &gt;, DIM_d &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>supp_intersect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
THIS ROUTINE IS INTENDED FOR THE SPECIAL CASE OF TRIVIAL PARAMETRIZATIONS, NAMELY AFFINE LINEAR MAPPINGS 'A x + B' WITH 'A' BEEING A DIAGONAL MATRIX. The function checks whether two wavelets intersect and returns an irregular partition of the support intersection pulled back to the unit cube by the chart corresponding to <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png">. This is needed to be able to exactly compute the entries of the stiffness matrix for the above case of very simple patch parametrizations. 
</div>
</div><p>
<a class="anchor" name="6d6670ec9613c9cf6ac3511a4b623429"></a><!-- doxytag: member="FrameTL::intersect_supports" ref="6d6670ec9613c9cf6ac3511a4b623429" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_mu)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::intersect_supports           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_mu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether the support of the wavelet frame elements <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png"> and <img class="formulaInl" alt="$\psi_\mu$" src="form_38.png"> intersect. The supports of the corresponding cube wavelets have to be passed as arguments supp_lambda and supp_mu. 
</div>
</div><p>
<a class="anchor" name="02c30f3ec04242a2445af8e588bae6b2"></a><!-- doxytag: member="FrameTL::intersect_supports_1D" ref="02c30f3ec04242a2445af8e588bae6b2" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const Index1D&lt; IBASIS &gt; &amp;lambda, const Index1D&lt; IBASIS &gt; &amp;mu, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_lambda, const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *supp_mu, const int dir, Array1D&lt; double &gt; &amp;supp_intersect)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::intersect_supports_1D           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index1D&lt; IBASIS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index1D&lt; IBASIS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CubeBasis&lt; IBASIS, DIM_d &gt;::Support *&nbsp;</td>
          <td class="paramname"> <em>supp_mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array1D&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>supp_intersect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks whether the supports of the two functions given by lambda and mu intersect. It also generates an irregular partition of the support intersection pulled back to the unit interval by the parametric mapping corresponding to lambda. 
</div>
</div><p>
<a class="anchor" name="8008f4b3d0a7bb7acab2b74a29d60222"></a><!-- doxytag: member="FrameTL::intersect_supports_simple" ref="8008f4b3d0a7bb7acab2b74a29d60222" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;mu)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::intersect_supports_simple           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether the support of the wavelet frame elements intersect. WE ASSUME THAT THE PATCHES ARE RECTANGULAR AND THAT THEY ARE ALIGNED WITH THE CARTESIAN GRID. 
</div>
</div><p>
<a class="anchor" name="0005c53dfff8661290582ea77b5ebcff"></a><!-- doxytag: member="FrameTL::intersecting_wavelets" ref="0005c53dfff8661290582ea77b5ebcff" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const int p, const std::set&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;Lambda, std::list&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;intersecting)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::intersecting_wavelets           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>intersecting</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a given wavelet frame element <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png">, compute all generators/wavelets from patch p in the set Lambda, the supports of which intersect the one of <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png">. WE ASSUME AGAIN THAT ONLY RECTANGULAR PATCHTES ALIGNED WITH THE COORDINATE AXES ARE USED. 
</div>
</div><p>
<a class="anchor" name="1823fb7effb657b388e652efbef319b3"></a><!-- doxytag: member="FrameTL::intersecting_wavelets" ref="1823fb7effb657b388e652efbef319b3" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const int j, const bool generators, std::list&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;intersecting)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::intersecting_wavelets           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>generators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>intersecting</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a given wavelet frame element <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png">, compute all generators/wavelets <img class="formulaInl" alt="$\psi_\nu$" src="form_39.png"> with level <img class="formulaInl" alt="$|\nu|=j$" src="form_40.png">, such that the respective supports have a nontrivial intersection. 
</div>
</div><p>
<a class="anchor" name="e57f8b33a1d5167ca7a23c7762e9ad1a"></a><!-- doxytag: member="FrameTL::intersecting_wavelets_on_patch" ref="e57f8b33a1d5167ca7a23c7762e9ad1a" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;frame, const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;lambda, const int p, const int j, const bool generators, std::list&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;intersecting)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::intersecting_wavelets_on_patch           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>generators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>intersecting</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a given wavelet frame element <img class="formulaInl" alt="$\psi_\lambda$" src="form_27.png">, compute all generators/wavelets <img class="formulaInl" alt="$\psi_\nu$" src="form_39.png"> with level <img class="formulaInl" alt="$|\nu|=j$" src="form_40.png"> on patch p, such that the respective supports have a nontrivial intersection. WE ASSUME AGAIN THAT ONLY RECTANGULAR PATCHTES ALIGNED WITH THE COORDINATE AXES ARE USED. 
</div>
</div><p>
<a class="anchor" name="a6650ac9337756c12f5022699c50cc28"></a><!-- doxytag: member="FrameTL::last_generator" ref="a6650ac9337756c12f5022699c50cc28" args="(const FRAME *frame, const int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt; FrameTL::last_generator           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of last generator on level <img class="formulaInl" alt="$j \geq j_0$" src="form_4.png">. 
</div>
</div><p>
<a class="anchor" name="0544af1a279910dc8bcdb9b542df3166"></a><!-- doxytag: member="FrameTL::last_generator_num" ref="0544af1a279910dc8bcdb9b542df3166" args="(const FRAME *frame)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int FrameTL::last_generator_num           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of last generator on level <img class="formulaInl" alt="$j_0$" src="form_5.png">. 
</div>
</div><p>
<a class="anchor" name="7c29f890e91e2cd966b9ac6b773277cf"></a><!-- doxytag: member="FrameTL::last_wavelet" ref="7c29f890e91e2cd966b9ac6b773277cf" args="(const FRAME *frame, const int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>&lt; IBASIS, DIM_d, DIM_m &gt; FrameTL::last_wavelet           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of last wavelet on level <img class="formulaInl" alt="$j \geq j_0$" src="form_4.png">. 
</div>
</div><p>
<a class="anchor" name="98345f161b05ac9604fbd9070da0bba7"></a><!-- doxytag: member="FrameTL::last_wavelet_num" ref="98345f161b05ac9604fbd9070da0bba7" args="(const FRAME *frame, const int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m, class FRAME&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int FrameTL::last_wavelet_num           </td>
          <td>(</td>
          <td class="paramtype">const FRAME *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of last wavelet on level <img class="formulaInl" alt="$j \geq j0$" src="form_37.png">. 
</div>
</div><p>
<a class="anchor" name="a6fc7f7f5f218c3dc3e34081b4e7464d"></a><!-- doxytag: member="FrameTL::MultSchw" ref="a6fc7f7f5f218c3dc3e34081b4e7464d" args="(const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::MultSchw           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>approximations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adaptive multiplicative Schwarz wavelet frame algorithm from Stevenson, Werner 2009. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The cached discrete problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The target <img class="formulaInl" alt="$\ell_2$" src="form_0.png">-accuracy of the algorithm. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>approximations</em>&nbsp;</td><td>An array of length number of patches +1. We return in this array the local discrete approximations on each patch. The last entry contains the final global discrete approximation at termination. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f3d9112d64f468a664317686725617bd"></a><!-- doxytag: member="FrameTL::NGROW" ref="f3d9112d64f468a664317686725617bd" args="(const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_bar, const double xi1, const double xi2, set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda_tilde, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r, const int jmax, const CompressionStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::NGROW           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CDD1Parameters &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u_bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>xi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>xi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda_tilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompressionStrategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
NGROW. 
<p>
Given a set Lambda, an initial approximation ubar (supported in Lambda) to the Galerkin solutin u_Lambda of Au = F, calculate an approximate residual r with ||r-r_Lambda||_2 &lt;= xi_1 + xi_2 + c_2 * ||ubar-u_Lambda||_2 and a new index set Lambda_tilde Lambda as small as possible such that ||P_{Lambda_tilde Lambda}r||_2 &gt;= gamma * ||r||_2 
</div>
</div><p>
<a class="anchor" name="6fd34de92145c0f42b41f9b36a379e9f"></a><!-- doxytag: member="FrameTL::norm2" ref="6fd34de92145c0f42b41f9b36a379e9f" args="(Point&lt; DIM &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double FrameTL::norm2           </td>
          <td>(</td>
          <td class="paramtype">Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
computes l_2 inner product will be placed in class Point in the future or replaced by appropriate function in class tensor 
</div>
</div><p>
<a class="anchor" name="d25b2eb9873b17224cdc0ddc9b0d04b1"></a><!-- doxytag: member="FrameTL::NPROG" ref="d25b2eb9873b17224cdc0ddc9b0d04b1" args="(const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double delta, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v_hat, set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda_hat, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r_hat, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;u_Lambda_k, const int jmax, const CompressionStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::NPROG           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CDD1Parameters &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v_hat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda_hat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r_hat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u_Lambda_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompressionStrategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
NPROG. 
<p>
Given an approximation v (the support of which is contained in Lambda) to the exact Galerkin solution u of Au = F with ||u-v||_2 &lt;= delta, compute a new approximation v_hat supported in Lambda_hat, such that ||u-v_hat||_2 &lt;= delta/2. An approximate residual r_hat as well as the last iterand ubar before the final thresholding are also returned. 
</div>
</div><p>
<a class="anchor" name="e86daf5e125e66504844e002ba3dc4b5"></a><!-- doxytag: member="FrameTL::NRESIDUAL" ref="e86daf5e125e66504844e002ba3dc4b5" args="(const PROBLEM &amp;P, const int patch, const CDD1Parameters &amp;params, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;F, const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda, const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;v, const double eta1, const double eta2, InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;r, set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;Lambda_tilde, const int jmax, const CompressionStrategy strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::NRESIDUAL           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CDD1Parameters &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; typename PROBLEM::WaveletBasis::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Lambda_tilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompressionStrategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
NRESIDUAL. 
<p>
Given an index set Lambda, an approximation v to the exact Galerkin solution u_Lambda of Au = F, calculate an approximate residual r (not necessarily supported in J), such that ||r - r_Lambda||_2 &lt;= eta_1 + eta_2 + c_2 * ||v-u_Lambda||_2 The routine also returns the support set Lambda_tilde of the approximate residual r. 
</div>
</div><p>
<a class="anchor" name="4f787a15e5a101207d222e0a799a7e5d"></a><!-- doxytag: member="FrameTL::operator&lt;&lt;" ref="4f787a15e5a101207d222e0a799a7e5d" args="(std::ostream &amp;os, const FrameIndex&lt; IBASIS, DIM_d, DIM_m &gt; &amp;lambda)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; FrameTL::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameIndex&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream output for <a class="el" href="classFrameTL_1_1FrameIndex.html">FrameIndex</a>. 
</div>
</div><p>
<a class="anchor" name="218a9a8d5b69562375139a49043fce0b"></a><!-- doxytag: member="FrameTL::operator&lt;&lt;" ref="218a9a8d5b69562375139a49043fce0b" args="(std::ostream &amp;, const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; FrameTL::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
stream output of an <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a> 
</div>
</div><p>
<a class="anchor" name="d4045e5ba1e89e5fbdd9084024f16ae0"></a><!-- doxytag: member="FrameTL::pos_wrt_line" ref="d4045e5ba1e89e5fbdd9084024f16ae0" args="(const Point&lt; DIM &gt; &amp;p, const Point&lt; DIM &gt; &amp;p1, const Point&lt; DIM &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned short int FrameTL::pos_wrt_line           </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether p lies left of right of or on the line specified by the Points p1 and p2. This line's orientation is given by the vector starting in p1 and ending in p2. returning 0 means RIGHT OF LINE returning 1 means LEFT OF LINE returning 2 means ON LINE 
</div>
</div><p>
<a class="anchor" name="d92777b6b7c3d1dc873761d9280ec994"></a><!-- doxytag: member="FrameTL::precompute_supports_simple" ref="d92777b6b7c3d1dc873761d9280ec994" args="(const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; *frame, Array1D&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Support &gt; &amp;all_patch_supports)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IBASIS, unsigned int DIM_d, unsigned int DIM_m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::precompute_supports_simple           </td>
          <td>(</td>
          <td class="paramtype">const AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt; *&nbsp;</td>
          <td class="paramname"> <em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array1D&lt; typename AggregatedFrame&lt; IBASIS, DIM_d, DIM_m &gt;::Support &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>all_patch_supports</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For the case of rectangular patches, the supports of all wavelets frame elements between minimal and maximal level are computed. This routine is supposed to be called during the initialization process of an <a class="el" href="classFrameTL_1_1AggregatedFrame.html">AggregatedFrame</a> in its constructor. 
</div>
</div><p>
<a class="anchor" name="0f4762cff5b194a929e2eadddbfd0d71"></a><!-- doxytag: member="FrameTL::quadrangles_intersect" ref="0f4762cff5b194a929e2eadddbfd0d71" args="(FixedArray1D&lt; Point&lt; DIM &gt;, 4 &gt; poly1, FixedArray1D&lt; Point&lt; DIM &gt;, 4 &gt; poly2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FrameTL::quadrangles_intersect           </td>
          <td>(</td>
          <td class="paramtype">FixedArray1D&lt; Point&lt; DIM &gt;, 4 &gt;&nbsp;</td>
          <td class="paramname"> <em>poly1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FixedArray1D&lt; Point&lt; DIM &gt;, 4 &gt;&nbsp;</td>
          <td class="paramname"> <em>poly2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks whether the convex qudrangles given by the vertices in poly1 and poly2 have a non-trivial intersection. 
</div>
</div><p>
<a class="anchor" name="3ea47092508598512ecc54955117a16f"></a><!-- doxytag: member="FrameTL::receive_all_parts" ref="3ea47092508598512ecc54955117a16f" args="(const PROBLEM &amp;P, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::receive_all_parts           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All processors, apart from the master, receive an InfiniteVector&lt;double, typename PROBLEM::Index&gt;. This routine is intended to work hand in hand with broadcast_vec_from_Master. In a parallel adaptive Schwarz frame algorithm, the master broadcasts the new global discrete iterate in an InfiniteVector&lt;double, typename PROBLEM::Index&gt; while the others are receiving this message with receive_all_parts. 
</div>
</div><p>
<a class="anchor" name="868f995657a7f68345fe24340658282e"></a><!-- doxytag: member="FrameTL::send_to_Master" ref="868f995657a7f68345fe24340658282e" args="(const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::send_to_Master           </td>
          <td>(</td>
          <td class="paramtype">const InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine sends an InfiniteVector&lt;double, typename PROBLEM::Index&gt; from the current processor to the mater (the one with pid 0). 
</div>
</div><p>
<a class="anchor" name="010a7b97f26561b6923f285c1cbb8d02"></a><!-- doxytag: member="FrameTL::setup_coefficient_datatype" ref="010a7b97f26561b6923f285c1cbb8d02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::setup_coefficient_datatype           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create mpi datatype, consisting of an int and a double. Don't forget to call this routine at the very beginning of the mpi program. 
</div>
</div><p>
<a class="anchor" name="c04ff1f80c162c3369928a2b45402beb"></a><!-- doxytag: member="FrameTL::simplified_steepest_descent_SOLVE" ref="c04ff1f80c162c3369928a2b45402beb" args="(const PROBLEM &amp;problem, const double epsilon, InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;u_epsilon, const int jmax)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::simplified_steepest_descent_SOLVE           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfiniteVector&lt; double, typename PROBLEM::Index &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u_epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of a simplified steepest descent solver as described in [DRWFS] Simplified means that the appearing constants are "guessed" and not estimated as in above publication. That is, we have a standard steepest descent algorithm with APPLY and RHS instead of the normal matrix vector operations. The main iteration step is u := u + alpha * (RHS[eta] - APPLY[eta, u]) with the acceleration parameter alpha = res^T res / (res^T APPLY[eta, res]) and the residual res = (RHS[eta] - APPLY[eta, u])<p>
[DRWFS] Stephan Dahlke, Thorsten Raasch, Manuel Werner, Massimo Fornasier and Rob Stevenson Adaptive frame methods for elliptic operator equations: the steepest descent approach 
</div>
</div><p>
<a class="anchor" name="b98b858d0561768f9494ac7f962a6857"></a><!-- doxytag: member="FrameTL::steepest_descent_SOLVE" ref="b98b858d0561768f9494ac7f962a6857" args="(const PROBLEM &amp;P, const double epsilon, Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;approximations)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FrameTL::steepest_descent_SOLVE           </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array1D&lt; InfiniteVector&lt; double, typename PROBLEM::Index &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>approximations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adaptive steepest descent wavelet frame algorithm from Dahlke, Fornasier, Raasch, Stevenson, Werner 2007. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The cached discrete problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The target <img class="formulaInl" alt="$\ell_2$" src="form_0.png">-accuracy of the algorithm. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>approximations</em>&nbsp;</td><td>An array of length number of patches+1. We return in this array the local discrete approximations on each patch. The last entry contains the final global discrete approximation at termination. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab03f9658bfef63434301affb3b5803a"></a><!-- doxytag: member="FrameTL::sub" ref="ab03f9658bfef63434301affb3b5803a" args="(const Point&lt; DIM &gt; &amp;p, const Vector&lt; double &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Point&lt;DIM&gt; FrameTL::sub           </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
difference between Point p, viewed as vector, and Vector b 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Sep 4 16:28:50 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>

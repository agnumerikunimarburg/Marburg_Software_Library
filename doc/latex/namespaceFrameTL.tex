\hypertarget{namespaceFrameTL}{
\section{FrameTL Namespace Reference}
\label{namespaceFrameTL}\index{FrameTL@{FrameTL}}
}


\subsection*{Classes}
\begin{CompactItemize}
\item 
class \textbf{PolySolBiharmonic}
\item 
class \textbf{SimpleTest}
\item 
class \textbf{SimpleTestRHS}
\item 
class \textbf{SimpleTestGradient}
\item 
class \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}
\item 
class \hyperlink{classFrameTL_1_1Biharmonic1D__Solution}{Biharmonic1D\_\-Solution}
\item 
class \hyperlink{classFrameTL_1_1Biharmonic1D__RHS__Integrand}{Biharmonic1D\_\-RHS\_\-Integrand}
\item 
class \hyperlink{classFrameTL_1_1Biharmonic1D__RHS}{Biharmonic1D\_\-RHS}
\item 
class \hyperlink{classFrameTL_1_1BiharmonicEquation}{BiharmonicEquation}
\item 
struct \textbf{CDD1Parameters}
\item 
class \hyperlink{classFrameTL_1_1Singularity1D__RHS__2}{Singularity1D\_\-RHS\_\-2}
\item 
class \hyperlink{classFrameTL_1_1Singularity1D__2}{Singularity1D\_\-2}
\item 
class \hyperlink{classFrameTL_1_1EllipticEquation}{EllipticEquation}
\item 
class \hyperlink{classFrameTL_1_1EvaluateFrame}{EvaluateFrame}
\item 
class \textbf{EvaluateFrame$<$ IBASIS, 1, 1 $>$}
\item 
class \textbf{EvaluateFrame$<$ IBASIS, 2, 2 $>$}
\item 
struct \hyperlink{structFrameTL_1_1Coefficient}{Coefficient}
\item 
class \hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}
\item 
class \hyperlink{classFrameTL_1_1Functional}{Functional}
\item 
class \hyperlink{classFrameTL_1_1Index1D}{Index1D}
\item 
class \hyperlink{classFrameTL_1_1Singularity1D__2__prime}{Singularity1D\_\-2\_\-prime}
\item 
class \hyperlink{classFrameTL_1_1Poisson__Solution__Ring}{Poisson\_\-Solution\_\-Ring}
\item 
class \hyperlink{classFrameTL_1_1Poisson__RHS__Ring}{Poisson\_\-RHS\_\-Ring}
\item 
class \hyperlink{classFrameTL_1_1Poisson__SolutionGradient__Ring}{Poisson\_\-SolutionGradient\_\-Ring}
\item 
class \hyperlink{classFrameTL_1_1SimpleBiharmonicEquation}{SimpleBiharmonicEquation}
\item 
class \hyperlink{classFrameTL_1_1SimpleEllipticEquation}{SimpleEllipticEquation}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
\hypertarget{namespaceFrameTL_5f7cd84df62cbac0d03d55a63858d138}{
{\footnotesize template$<$class IBASIS, int DIM$>$ }\\double \textbf{H\_\-1\_\-error\_\-interval} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM, DIM $>$ \&frame, const InfiniteVector$<$ double, typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM, DIM $>$::Index $>$ \&coeffs, const Function$<$ 1 $>$ \&f)}
\label{namespaceFrameTL_5f7cd84df62cbac0d03d55a63858d138}

\item 
\hypertarget{namespaceFrameTL_1b900f7d22f4b32129f53074030c4d85}{
{\footnotesize template$<$class IBASIS, int DIM$>$ }\\double \textbf{error\_\-H\_\-scale\_\-interval} (const int order, const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM, DIM $>$ \&frame, const InfiniteVector$<$ double, typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM, DIM $>$::Index $>$ \&coeffs, const Function$<$ 1 $>$ \&f)}
\label{namespaceFrameTL_1b900f7d22f4b32129f53074030c4d85}

\item 
\hypertarget{namespaceFrameTL_2c2397a9802a34ffc082c4de792c808d}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{thin\_\-out\_\-ring} (PROBLEM \&P, const int i, const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-sparse, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-very\_\-sparse)}
\label{namespaceFrameTL_2c2397a9802a34ffc082c4de792c808d}

\item 
\hypertarget{namespaceFrameTL_9e04ddf27423214b1a0ffa4060ce6224}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{thin\_\-out} (PROBLEM \&P, const int i, const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-sparse, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-very\_\-sparse)}
\label{namespaceFrameTL_9e04ddf27423214b1a0ffa4060ce6224}

\item 
\hypertarget{namespaceFrameTL_4c6e64c8471915c044140f434fd54372}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{remove\_\-i} (const int i, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u)}
\label{namespaceFrameTL_4c6e64c8471915c044140f434fd54372}

\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_fae0f5be715e2324d15ca01a18665855}{AddSchw} (const PROBLEM \&P, const double epsilon, Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \&approximations)
\begin{CompactList}\small\item\em Adaptive additive Schwarz wavelet frame algorithm from PhD thesis Werner 2009. \item\end{CompactList}\item 
\hypertarget{namespaceFrameTL_9af3764c23011a0c0d4ceb60995cae01}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{split} (PROBLEM \&P, const int i, const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u1, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u2)}
\label{namespaceFrameTL_9af3764c23011a0c0d4ceb60995cae01}

\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_a6fc7f7f5f218c3dc3e34081b4e7464d}{MultSchw} (const PROBLEM \&P, const double epsilon, Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \&approximations)
\begin{CompactList}\small\item\em Adaptive multiplicative Schwarz wavelet frame algorithm from Stevenson, Werner 2009. \item\end{CompactList}\item 
\hypertarget{namespaceFrameTL_3ee8bc795a39cbc2a1084ff7f9735da1}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{adaptive\_\-multiplicative\_\-Schwarz\_\-SOLVE} (const PROBLEM \&P, const double epsilon, Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \&approximations)}
\label{namespaceFrameTL_3ee8bc795a39cbc2a1084ff7f9735da1}

\item 
\hypertarget{namespaceFrameTL_c081a164d56c41204ca6981f3eca36a7}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{GALERKIN} (PROBLEM \&P, const set$<$ typename PROBLEM::Index $>$ \&Lambda, const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&rhs, Vector$<$ double $>$ \&u)}
\label{namespaceFrameTL_c081a164d56c41204ca6981f3eca36a7}

\item 
\hypertarget{namespaceFrameTL_a4b0c696b6cd000adf04b5fb5c484a04}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{additive\_\-Schwarz\_\-SOLVE} (PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_a4b0c696b6cd000adf04b5fb5c484a04}

\item 
\hypertarget{namespaceFrameTL_affbbbc817346e4a1c801ff4f2f38f5d}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{addtive\_\-Schwarz\_\-SOLVE} (PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_affbbbc817346e4a1c801ff4f2f38f5d}

\item 
\hypertarget{namespaceFrameTL_6ea4f0fd019efd168c07f7dd5a6aca4c}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{additive\_\-Schwarz\_\-SD\_\-SOLVE} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_6ea4f0fd019efd168c07f7dd5a6aca4c}

\item 
\hypertarget{namespaceFrameTL_0f8abfca6433dce3a533205aca27803c}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{addtive\_\-Schwarz\_\-SD\_\-SOLVE} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_0f8abfca6433dce3a533205aca27803c}

\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\void \hyperlink{namespaceFrameTL_d92777b6b7c3d1dc873761d9280ec994}{precompute\_\-supports\_\-simple} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ $\ast$frame, Array1D$<$ typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Support $>$ \&all\_\-patch\_\-supports)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\std::ostream \& \hyperlink{namespaceFrameTL_218a9a8d5b69562375139a49043fce0b}{operator$<$$<$} (std::ostream \&, const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&)
\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_8a92efb82d1634c8cf05737d5164b731}{CDD1\_\-LOCAL\_\-SOLVE} (const PROBLEM \&P, const int patch, const double epsilon, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&guess, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&u\_\-epsilon, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v\_\-k, const int jmax, const CompressionStrategy strategy)
\begin{CompactList}\small\item\em The routine ALGORITHMc from \mbox{[}BB+\mbox{]}, with a given initial guess for u\_\-epsilon. \item\end{CompactList}\item 
\hypertarget{namespaceFrameTL_f1d8dd5608d705fbf2563b8a266d14a9}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_f1d8dd5608d705fbf2563b8a266d14a9}{CDD1\_\-LOCAL\_\-SOLVE} (const PROBLEM \&P, const int patch, const double epsilon, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&guess, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&u\_\-epsilon, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v\_\-k, const double c1, const double c2, const int jmax, const CompressionStrategy strategy)}
\label{namespaceFrameTL_f1d8dd5608d705fbf2563b8a266d14a9}

\begin{CompactList}\small\item\em The routine ALGORITHMc from \mbox{[}BB+\mbox{]}, with a given initial guess for u\_\-epsilon and for the parameters c1,c2. \item\end{CompactList}\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_d25b2eb9873b17224cdc0ddc9b0d04b1}{NPROG} (const PROBLEM \&P, const int patch, const CDD1Parameters \&params, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&F, const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v, const double delta, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v\_\-hat, set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda\_\-hat, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&r\_\-hat, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&u\_\-Lambda\_\-k, const int jmax, const CompressionStrategy strategy)
\begin{CompactList}\small\item\em NPROG. \item\end{CompactList}\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_5338ae7f2ce93a8449560cc020fa212a}{GALERKIN} (const PROBLEM \&P, const int patch, const CDD1Parameters \&params, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&F, const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v, const double delta, const double eta, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&u\_\-bar, const int jmax, const CompressionStrategy strategy)
\begin{CompactList}\small\item\em GALERKIN. \item\end{CompactList}\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_f3d9112d64f468a664317686725617bd}{NGROW} (const PROBLEM \&P, const int patch, const CDD1Parameters \&params, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&F, const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&u\_\-bar, const double xi1, const double xi2, set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda\_\-tilde, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&r, const int jmax, const CompressionStrategy strategy)
\begin{CompactList}\small\item\em NGROW. \item\end{CompactList}\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_cd7462527bff134a7c142ee0471d6ab2}{INRESIDUAL} (const PROBLEM \&P, const int patch, const CDD1Parameters \&params, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&F, const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v, const double eta1, const double eta2, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&r, const int jmax, const CompressionStrategy strategy)
\begin{CompactList}\small\item\em INRESIDUAL. \item\end{CompactList}\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_e86daf5e125e66504844e002ba3dc4b5}{NRESIDUAL} (const PROBLEM \&P, const int patch, const CDD1Parameters \&params, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&F, const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda, const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&v, const double eta1, const double eta2, InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \&r, set$<$ typename PROBLEM::WaveletBasis::Index $>$ \&Lambda\_\-tilde, const int jmax, const CompressionStrategy strategy)
\begin{CompactList}\small\item\em NRESIDUAL. \item\end{CompactList}\item 
\hypertarget{namespaceFrameTL_391c8708bf59582ba636bfb5a394d2b7}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{cg\_\-SOLVE} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_391c8708bf59582ba636bfb5a394d2b7}

\item 
{\footnotesize template$<$class IBASIS$>$ }\\double \hyperlink{namespaceFrameTL_addaaee53d308a6093a25ed95f86cc85}{error\_\-H\_\-scale\_\-interval} (const int order, const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, 1, 1 $>$ \&frame, const InfiniteVector$<$ double, typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, 1, 1 $>$::Index $>$ \&coeffs, const Function$<$ 1 $>$ \&f)
\begin{CompactList}\small\item\em This function computes the $L_2$-norm or $H^1$-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the unit interval. \item\end{CompactList}\item 
{\footnotesize template$<$class IBASIS$>$ }\\double \hyperlink{namespaceFrameTL_54aa679fc30456b9ca268846c1926992}{error\_\-H\_\-scale\_\-Lshaped} (const int order, const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, 2, 2 $>$ \&frame, const InfiniteVector$<$ double, typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, 2, 2 $>$::Index $>$ \&coeffs, const Function$<$ 2 $>$ \&f)
\begin{CompactList}\small\item\em This function computes the $L_2$-norm or $H^1$-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the L-shaped domain $[-1,1]^2 \ [0,1)^2$. \item\end{CompactList}\item 
double \hyperlink{namespaceFrameTL_3ce808a3f26fc1938139488a730e994d}{H\_\-1\_\-semi\_\-norm\_\-Lshaped} (const Function$<$ 2 $>$ \&gradient)
\begin{CompactList}\small\item\em Computes an approximation to the $H^1$-norm of a function in the L-shaped domain $[-1,1]^2 \ [0,1)^2$. \item\end{CompactList}\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\\hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \hyperlink{namespaceFrameTL_6f69a38cdff114000317fd48750b471b}{first\_\-generator} (const FRAME $\ast$frame, const int j)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\\hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \hyperlink{namespaceFrameTL_a6650ac9337756c12f5022699c50cc28}{last\_\-generator} (const FRAME $\ast$frame, const int j)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\\hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \hyperlink{namespaceFrameTL_ad2c37c6767c23fca5c2c3e1563680a5}{first\_\-wavelet} (const FRAME $\ast$frame, const int j)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\\hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \hyperlink{namespaceFrameTL_7c29f890e91e2cd966b9ac6b773277cf}{last\_\-wavelet} (const FRAME $\ast$frame, const int j)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\int \hyperlink{namespaceFrameTL_80cab15b10b2b3bff9e29f51409f7ce7}{first\_\-generator\_\-num} (const FRAME $\ast$frame)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\int \hyperlink{namespaceFrameTL_0544af1a279910dc8bcdb9b542df3166}{last\_\-generator\_\-num} (const FRAME $\ast$frame)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\int \hyperlink{namespaceFrameTL_d2a45d507a64c17ff1cf1edeb7afcd8e}{first\_\-wavelet\_\-num} (const FRAME $\ast$frame, const int j)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ }\\int \hyperlink{namespaceFrameTL_98345f161b05ac9604fbd9070da0bba7}{last\_\-wavelet\_\-num} (const FRAME $\ast$frame, const int j)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\std::ostream \& \hyperlink{namespaceFrameTL_4f787a15e5a101207d222e0a799a7e5d}{operator$<$$<$} (std::ostream \&os, const \hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&lambda)
\item 
\hypertarget{namespaceFrameTL_80a56eff444cfd2880b83403ab09e808}{
{\footnotesize template$<$class INDEX$>$ }\\void \textbf{to\_\-array} (const InfiniteVector$<$ double, INDEX $>$ \&ivec, \hyperlink{structFrameTL_1_1Coefficient}{Coefficient} $\ast$coeff\_\-array)}
\label{namespaceFrameTL_80a56eff444cfd2880b83403ab09e808}

\item 
\hypertarget{namespaceFrameTL_3b946e677f70c5b04b3cec8feeadc20e}{
{\footnotesize template$<$class INDEX, class FRAME$>$ }\\void \textbf{array\_\-to\_\-map} (const \hyperlink{structFrameTL_1_1Coefficient}{Coefficient} $\ast$coeff\_\-array, const FRAME $\ast$frame, InfiniteVector$<$ double, INDEX $>$ \&ivec, const int count)}
\label{namespaceFrameTL_3b946e677f70c5b04b3cec8feeadc20e}

\item 
\hypertarget{namespaceFrameTL_26ebfba3c24541d4c0b1e7591fbb6d47}{
bool \textbf{eq} (const double x, const double y)}
\label{namespaceFrameTL_26ebfba3c24541d4c0b1e7591fbb6d47}

\item 
\hypertarget{namespaceFrameTL_6bb8df9a03d57ebc0a19a9d58fddf19b}{
bool \textbf{lt} (const double x, const double y)}
\label{namespaceFrameTL_6bb8df9a03d57ebc0a19a9d58fddf19b}

\item 
\hypertarget{namespaceFrameTL_8004ad60ec83531e6c45e0e45d09d73b}{
bool \textbf{gt} (const double x, const double y)}
\label{namespaceFrameTL_8004ad60ec83531e6c45e0e45d09d73b}

\item 
\hypertarget{namespaceFrameTL_524bc935ed1e0794c223e364ce0dbc96}{
bool \textbf{leq} (const double x, const double y)}
\label{namespaceFrameTL_524bc935ed1e0794c223e364ce0dbc96}

\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\unsigned short int \hyperlink{namespaceFrameTL_d4045e5ba1e89e5fbdd9084024f16ae0}{pos\_\-wrt\_\-line} (const Point$<$ DIM $>$ \&p, const Point$<$ DIM $>$ \&p1, const Point$<$ DIM $>$ \&p2)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_0699f5e7931ab40bf346b17e6c3bde01}{in\_\-support} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const Point$<$ DIM\_\-m $>$ \&p)
\item 
\hypertarget{namespaceFrameTL_42d9dd29c91fe172a30736eb38ee21e9}{
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \textbf{in\_\-support} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-lambda, const Point$<$ DIM\_\-m $>$ \&p)}
\label{namespaceFrameTL_42d9dd29c91fe172a30736eb38ee21e9}

\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_6d6670ec9613c9cf6ac3511a4b623429}{intersect\_\-supports} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&mu, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-lambda, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-mu)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_8008f4b3d0a7bb7acab2b74a29d60222}{intersect\_\-supports\_\-simple} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&mu)
\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\bool \hyperlink{namespaceFrameTL_0f4762cff5b194a929e2eadddbfd0d71}{quadrangles\_\-intersect} (FixedArray1D$<$ Point$<$ DIM $>$, 4 $>$ poly1, FixedArray1D$<$ Point$<$ DIM $>$, 4 $>$ poly2)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_02c30f3ec04242a2445af8e588bae6b2}{intersect\_\-supports\_\-1D} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const \hyperlink{classFrameTL_1_1Index1D}{Index1D}$<$ IBASIS $>$ \&lambda, const \hyperlink{classFrameTL_1_1Index1D}{Index1D}$<$ IBASIS $>$ \&mu, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-lambda, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-mu, const int dir, Array1D$<$ double $>$ \&supp\_\-intersect)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_5aeecded043a910b0dae7228883304b3}{intersect\_\-supports} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&mu, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-lambda, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-mu, FixedArray1D$<$ Array1D$<$ double $>$, DIM\_\-d $>$ \&supp\_\-intersect)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\void \hyperlink{namespaceFrameTL_1823fb7effb657b388e652efbef319b3}{intersecting\_\-wavelets} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const int j, const bool generators, std::list$<$ typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \&intersecting)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\void \hyperlink{namespaceFrameTL_0005c53dfff8661290582ea77b5ebcff}{intersecting\_\-wavelets} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const int p, const std::set$<$ typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \&Lambda, std::list$<$ typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \&intersecting)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\void \hyperlink{namespaceFrameTL_e57f8b33a1d5167ca7a23c7762e9ad1a}{intersecting\_\-wavelets\_\-on\_\-patch} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const int p, const int j, const bool generators, std::list$<$ typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \&intersecting)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_27f6cca23b933ff76a0597a62f5dd870}{intersect\_\-singular\_\-support} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&mu)
\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\int \hyperlink{namespaceFrameTL_179a53ae796b31d73b591456b7e8240e}{edgesIntersect} (const Point$<$ DIM $>$ \&A, const Point$<$ DIM $>$ \&B, const Point$<$ DIM $>$ \&C, const Point$<$ DIM $>$ \&D)
\item 
{\footnotesize template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ }\\bool \hyperlink{namespaceFrameTL_0b6d3a80be9f0dd032527c3c17ce3f62}{intersect\_\-supports} (const \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&frame, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&lambda, const typename \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \&mu, const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$supp\_\-lambda)
\item 
{\footnotesize template$<$unsigned int DIM, class VALUE$>$ }\\const Point$<$ DIM $>$ \hyperlink{namespaceFrameTL_110b0b11455f5d648c2cb3a7866f3900}{apply} (const Matrix$<$ VALUE $>$ \&M, const Point$<$ DIM $>$ \&p)
\item 
{\footnotesize template$<$unsigned int DIM, class VALUE$>$ }\\void \hyperlink{namespaceFrameTL_7f2d7a0a9f79b15e8d82ff8363d06bb5}{apply} (const Matrix$<$ VALUE $>$ \&M, const Point$<$ DIM $>$ \&p, Point$<$ DIM $>$ \&res)
\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\Point$<$ DIM $>$ \hyperlink{namespaceFrameTL_fd9af4210f87f330a600bdba74ca3f6d}{add} (const Point$<$ DIM $>$ \&p, const Vector$<$ double $>$ \&b)
\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\Point$<$ DIM $>$ \hyperlink{namespaceFrameTL_ab03f9658bfef63434301affb3b5803a}{sub} (const Point$<$ DIM $>$ \&p, const Vector$<$ double $>$ \&b)
\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\const double \hyperlink{namespaceFrameTL_b442ddca04900a00608a3963348b15bb}{inner\_\-prod} (const Point$<$ DIM $>$ \&p1, const Point$<$ DIM $>$ \&p2)
\item 
{\footnotesize template$<$unsigned int DIM$>$ }\\const double \hyperlink{namespaceFrameTL_6fd34de92145c0f42b41f9b36a379e9f}{norm2} (Point$<$ DIM $>$ \&p)
\item 
\hypertarget{namespaceFrameTL_d1c8aa47dd1f4024c97146dd88d48a72}{
{\footnotesize template$<$unsigned int DIM$>$ }\\void \textbf{swap} (const Point$<$ DIM $>$ \&p1, const Point$<$ DIM $>$ \&p2)}
\label{namespaceFrameTL_d1c8aa47dd1f4024c97146dd88d48a72}

\item 
\hypertarget{namespaceFrameTL_f10c19e668efd734a36e982750184b11}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{REDUCE\_\-REDUNDANCY} (PROBLEM \&P, const int i, const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-sparse)}
\label{namespaceFrameTL_f10c19e668efd734a36e982750184b11}

\item 
\hypertarget{namespaceFrameTL_6d0fc5d89ccc66faf29046d3bcfe3475}{
{\footnotesize template$<$class PROBLEM$>$ }\\bool \textbf{intersect\_\-line1} (PROBLEM \&P, const typename PROBLEM::Index \&lambda)}
\label{namespaceFrameTL_6d0fc5d89ccc66faf29046d3bcfe3475}

\item 
\hypertarget{namespaceFrameTL_7ba0009c3b5505a7a9a720663d21526d}{
{\footnotesize template$<$class PROBLEM$>$ }\\bool \textbf{intersect\_\-line2} (PROBLEM \&P, const typename PROBLEM::Index \&lambda)}
\label{namespaceFrameTL_7ba0009c3b5505a7a9a720663d21526d}

\item 
\hypertarget{namespaceFrameTL_30434f281b420f817ba55886c5b1bd82}{
{\footnotesize template$<$class PROBLEM$>$ }\\bool \textbf{contact\_\-with\_\-patch2} (PROBLEM \&P, const typename PROBLEM::Index \&lambda)}
\label{namespaceFrameTL_30434f281b420f817ba55886c5b1bd82}

\item 
\hypertarget{namespaceFrameTL_8d41aa77fa6da618ad97ddc75c920a55}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{multiplicative\_\-Schwarz\_\-SOLVE} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon\_\-0, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon\_\-1, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_8d41aa77fa6da618ad97ddc75c920a55}

\item 
void \hyperlink{namespaceFrameTL_010a7b97f26561b6923f285c1cbb8d02}{setup\_\-coefficient\_\-datatype} ()
\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_868f995657a7f68345fe24340658282e}{send\_\-to\_\-Master} (const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&v)
\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_3ea47092508598512ecc54955117a16f}{receive\_\-all\_\-parts} (const PROBLEM \&P, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&v)
\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_99afa22a98a5b20d8326b2983bb19088}{broadcast\_\-vec\_\-from\_\-Master} (const PROBLEM \&P, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&v)
\item 
void \hyperlink{namespaceFrameTL_5b01ba18f76ca06fb77d8cbca90492e8}{broadcast\_\-double\_\-from\_\-Master} (double \&d)
\item 
\hypertarget{namespaceFrameTL_bacf8c8fd02179e596a29355d939ec7c}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{richardson\_\-SOLVE} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon, Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \&approximations)}
\label{namespaceFrameTL_bacf8c8fd02179e596a29355d939ec7c}

\item 
\hypertarget{namespaceFrameTL_1111c8e69e372f889361af29dad3c8dd}{
\textbf{for} (int i=0;i$<$ P.basis().n\_\-p();i++)}
\label{namespaceFrameTL_1111c8e69e372f889361af29dad3c8dd}

\item 
\hypertarget{namespaceFrameTL_1a05babec2a9b0c713764d9ba15e2048}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{richardson\_\-SOLVE\_\-CDD2} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon)}
\label{namespaceFrameTL_1a05babec2a9b0c713764d9ba15e2048}

\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_c04ff1f80c162c3369928a2b45402beb}{simplified\_\-steepest\_\-descent\_\-SOLVE} (const PROBLEM \&problem, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon, const int jmax)
\item 
{\footnotesize template$<$class PROBLEM$>$ }\\void \hyperlink{namespaceFrameTL_b98b858d0561768f9494ac7f962a6857}{steepest\_\-descent\_\-SOLVE} (const PROBLEM \&P, const double epsilon, Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \&approximations)
\begin{CompactList}\small\item\em Adaptive steepest descent wavelet frame algorithm from Dahlke, Fornasier, Raasch, Stevenson, Werner 2007. \item\end{CompactList}\item 
\hypertarget{namespaceFrameTL_bb9619e1ba041c247f306eb45f1d0e90}{
{\footnotesize template$<$class PROBLEM$>$ }\\void \textbf{steepest\_\-descent1\_\-SOLVE} (const PROBLEM \&P, const double epsilon, InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&u\_\-epsilon, int jmax, InfiniteVector$<$ double, typename PROBLEM::Index $>$ rhs)}
\label{namespaceFrameTL_bb9619e1ba041c247f306eb45f1d0e90}

\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
\hypertarget{namespaceFrameTL_ed8caef1981377375248b70b9df6b085}{
MPI\_\-Datatype \textbf{coefficient\_\-datatype}}
\label{namespaceFrameTL_ed8caef1981377375248b70b9df6b085}

\item 
\hypertarget{namespaceFrameTL_ecdb4ced7f7d4e5fde0db90a76dd3741}{
\textbf{approximations} \mbox{[}P.basis().n\_\-p()\mbox{]} = u\_\-epsilon}
\label{namespaceFrameTL_ecdb4ced7f7d4e5fde0db90a76dd3741}

\end{CompactItemize}


\subsection{Detailed Description}
The namespace \hyperlink{namespaceFrameTL}{FrameTL}. 

\subsection{Function Documentation}
\hypertarget{namespaceFrameTL_fd9af4210f87f330a600bdba74ca3f6d}{
\index{FrameTL@{FrameTL}!add@{add}}
\index{add@{add}!FrameTL@{FrameTL}}
\subsubsection[add]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ Point$<$DIM$>$ FrameTL::add (const Point$<$ DIM $>$ \& {\em p}, \/  const Vector$<$ double $>$ \& {\em b})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_fd9af4210f87f330a600bdba74ca3f6d}


add Point p, viewed as vector, to Vector b \hypertarget{namespaceFrameTL_fae0f5be715e2324d15ca01a18665855}{
\index{FrameTL@{FrameTL}!AddSchw@{AddSchw}}
\index{AddSchw@{AddSchw}!FrameTL@{FrameTL}}
\subsubsection[AddSchw]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::AddSchw (const PROBLEM \& {\em P}, \/  const double {\em epsilon}, \/  Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \& {\em approximations})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_fae0f5be715e2324d15ca01a18665855}


Adaptive additive Schwarz wavelet frame algorithm from PhD thesis Werner 2009. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em P}]The cached discrete problem. \item[{\em epsilon}]The target $\ell_2$-accuracy of the algorithm. \item[{\em approximations}]An array of length number of patches+1. We return in this array the local discrete approximations on each patch.\} The last entry contains the final global discrete approximation at termination. \end{description}
\end{Desc}
\hypertarget{namespaceFrameTL_7f2d7a0a9f79b15e8d82ff8363d06bb5}{
\index{FrameTL@{FrameTL}!apply@{apply}}
\index{apply@{apply}!FrameTL@{FrameTL}}
\subsubsection[apply]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM, class VALUE$>$ void FrameTL::apply (const Matrix$<$ VALUE $>$ \& {\em M}, \/  const Point$<$ DIM $>$ \& {\em p}, \/  Point$<$ DIM $>$ \& {\em res})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_7f2d7a0a9f79b15e8d82ff8363d06bb5}


apply matrix M to point p (p viewed as a vector) \hypertarget{namespaceFrameTL_110b0b11455f5d648c2cb3a7866f3900}{
\index{FrameTL@{FrameTL}!apply@{apply}}
\index{apply@{apply}!FrameTL@{FrameTL}}
\subsubsection[apply]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM, class VALUE$>$ const Point$<$DIM$>$ FrameTL::apply (const Matrix$<$ VALUE $>$ \& {\em M}, \/  const Point$<$ DIM $>$ \& {\em p})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_110b0b11455f5d648c2cb3a7866f3900}


apply matrix M to point p (p viewed as a vector) \hypertarget{namespaceFrameTL_5b01ba18f76ca06fb77d8cbca90492e8}{
\index{FrameTL@{FrameTL}!broadcast\_\-double\_\-from\_\-Master@{broadcast\_\-double\_\-from\_\-Master}}
\index{broadcast\_\-double\_\-from\_\-Master@{broadcast\_\-double\_\-from\_\-Master}!FrameTL@{FrameTL}}
\subsubsection[broadcast\_\-double\_\-from\_\-Master]{\setlength{\rightskip}{0pt plus 5cm}void FrameTL::broadcast\_\-double\_\-from\_\-Master (double \& {\em d})}}
\label{namespaceFrameTL_5b01ba18f76ca06fb77d8cbca90492e8}


The master processor sends a double to all other (slave) processors. \hypertarget{namespaceFrameTL_99afa22a98a5b20d8326b2983bb19088}{
\index{FrameTL@{FrameTL}!broadcast\_\-vec\_\-from\_\-Master@{broadcast\_\-vec\_\-from\_\-Master}}
\index{broadcast\_\-vec\_\-from\_\-Master@{broadcast\_\-vec\_\-from\_\-Master}!FrameTL@{FrameTL}}
\subsubsection[broadcast\_\-vec\_\-from\_\-Master]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::broadcast\_\-vec\_\-from\_\-Master (const PROBLEM \&, \/  InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_99afa22a98a5b20d8326b2983bb19088}


The master processor sends an InfiniteVector$<$double, typename PROBLEM::Index$>$ to all other (slave) processors. \hypertarget{namespaceFrameTL_8a92efb82d1634c8cf05737d5164b731}{
\index{FrameTL@{FrameTL}!CDD1\_\-LOCAL\_\-SOLVE@{CDD1\_\-LOCAL\_\-SOLVE}}
\index{CDD1\_\-LOCAL\_\-SOLVE@{CDD1\_\-LOCAL\_\-SOLVE}!FrameTL@{FrameTL}}
\subsubsection[CDD1\_\-LOCAL\_\-SOLVE]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::CDD1\_\-LOCAL\_\-SOLVE (const PROBLEM \& {\em P}, \/  const int {\em patch}, \/  const double {\em epsilon}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em guess}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em u\_\-epsilon}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em v\_\-k}, \/  const int {\em jmax}, \/  const CompressionStrategy {\em strategy})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_8a92efb82d1634c8cf05737d5164b731}


The routine ALGORITHMc from \mbox{[}BB+\mbox{]}, with a given initial guess for u\_\-epsilon. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em P}]The global discrete (cached) problem. \item[{\em patch}]The patch on which the local auxiliary problem has to be solved. \item[{\em epsilon}]The target accuracy. \item[{\em gues}]The initial gues from which the adaptive Galerkin scheme is started. \item[{\em u\_\-epsilon}]The final approximation. \item[{\em v\_\-k}]For the case of the multiplicative Schwarz method a la Stevenson/Werner 2009, v\_\-k have to be the coefficients u\_\-k$^\wedge$\{(j)\}, j i f from eq. (6.1.23) in Manuel's PhD thesis. In the additive case, v\_\-k are the frame coeffients of the function in the first argument of the bilinear form a(.,.) in the right-hand side of the local problem in algorithm AddSchw on page 165 of Manuel's thesis. param jmax The maximal alevel of resolution. param strategy The compression strategy (the way to create the matrix A\_\-j from Definition 4.2 in Manuels PhD thesis).\} \end{description}
\end{Desc}
\hypertarget{namespaceFrameTL_179a53ae796b31d73b591456b7e8240e}{
\index{FrameTL@{FrameTL}!edgesIntersect@{edgesIntersect}}
\index{edgesIntersect@{edgesIntersect}!FrameTL@{FrameTL}}
\subsubsection[edgesIntersect]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ int FrameTL::edgesIntersect (const Point$<$ DIM $>$ \& {\em A}, \/  const Point$<$ DIM $>$ \& {\em B}, \/  const Point$<$ DIM $>$ \& {\em C}, \/  const Point$<$ DIM $>$ \& {\em D})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_179a53ae796b31d73b591456b7e8240e}


This routine tests whether the line segments defined by the points A and B as well as C and D intersect. 0 = no intersection 1 = infinitely many intersection points 2 = single intersection point, but at least one knot involved 3 = single intersection point situated in the inner of both line segments \hypertarget{namespaceFrameTL_addaaee53d308a6093a25ed95f86cc85}{
\index{FrameTL@{FrameTL}!error\_\-H\_\-scale\_\-interval@{error\_\-H\_\-scale\_\-interval}}
\index{error\_\-H\_\-scale\_\-interval@{error\_\-H\_\-scale\_\-interval}!FrameTL@{FrameTL}}
\subsubsection[error\_\-H\_\-scale\_\-interval]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS$>$ double FrameTL::error\_\-H\_\-scale\_\-interval (const int {\em order}, \/  const AggregatedFrame$<$ IBASIS, 1, 1 $>$ \& {\em frame}, \/  const InfiniteVector$<$ double, typename AggregatedFrame$<$ IBASIS, 1, 1 $>$::Index $>$ \& {\em coeffs}, \/  const Function$<$ 1 $>$ \& {\em f})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_addaaee53d308a6093a25ed95f86cc85}


This function computes the $L_2$-norm or $H^1$-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the unit interval. 

The last parameter of this routine has to be the function, or, in case of the $H^1$-seminorm, it has to be the derivative of the function. \hypertarget{namespaceFrameTL_54aa679fc30456b9ca268846c1926992}{
\index{FrameTL@{FrameTL}!error\_\-H\_\-scale\_\-Lshaped@{error\_\-H\_\-scale\_\-Lshaped}}
\index{error\_\-H\_\-scale\_\-Lshaped@{error\_\-H\_\-scale\_\-Lshaped}!FrameTL@{FrameTL}}
\subsubsection[error\_\-H\_\-scale\_\-Lshaped]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS$>$ double FrameTL::error\_\-H\_\-scale\_\-Lshaped (const int {\em order}, \/  const AggregatedFrame$<$ IBASIS, 2, 2 $>$ \& {\em frame}, \/  const InfiniteVector$<$ double, typename AggregatedFrame$<$ IBASIS, 2, 2 $>$::Index $>$ \& {\em coeffs}, \/  const Function$<$ 2 $>$ \& {\em f})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_54aa679fc30456b9ca268846c1926992}


This function computes the $L_2$-norm or $H^1$-seminorm of the difference between the frame expansion given by the coefficients in coeffs and a given function in the L-shaped domain $[-1,1]^2 \ [0,1)^2$. 

The last parameter of this routine has to be the function, or, in case of the $H^1$-seminorm, it has to be the gradient of the function. \hypertarget{namespaceFrameTL_6f69a38cdff114000317fd48750b471b}{
\index{FrameTL@{FrameTL}!first\_\-generator@{first\_\-generator}}
\index{first\_\-generator@{first\_\-generator}!FrameTL@{FrameTL}}
\subsubsection[first\_\-generator]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ {\bf FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ FrameTL::first\_\-generator (const FRAME $\ast$ {\em frame}, \/  const int {\em j})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_6f69a38cdff114000317fd48750b471b}


Index of first generator on level $j \geq j_0$. \hypertarget{namespaceFrameTL_80cab15b10b2b3bff9e29f51409f7ce7}{
\index{FrameTL@{FrameTL}!first\_\-generator\_\-num@{first\_\-generator\_\-num}}
\index{first\_\-generator\_\-num@{first\_\-generator\_\-num}!FrameTL@{FrameTL}}
\subsubsection[first\_\-generator\_\-num]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ int FrameTL::first\_\-generator\_\-num (const FRAME $\ast$ {\em frame})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_80cab15b10b2b3bff9e29f51409f7ce7}


Number of first generator on level $j_0$. \hypertarget{namespaceFrameTL_ad2c37c6767c23fca5c2c3e1563680a5}{
\index{FrameTL@{FrameTL}!first\_\-wavelet@{first\_\-wavelet}}
\index{first\_\-wavelet@{first\_\-wavelet}!FrameTL@{FrameTL}}
\subsubsection[first\_\-wavelet]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ {\bf FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ FrameTL::first\_\-wavelet (const FRAME $\ast$ {\em frame}, \/  const int {\em j})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_ad2c37c6767c23fca5c2c3e1563680a5}


Index of first wavelet on level $j \geq j_0$. \hypertarget{namespaceFrameTL_d2a45d507a64c17ff1cf1edeb7afcd8e}{
\index{FrameTL@{FrameTL}!first\_\-wavelet\_\-num@{first\_\-wavelet\_\-num}}
\index{first\_\-wavelet\_\-num@{first\_\-wavelet\_\-num}!FrameTL@{FrameTL}}
\subsubsection[first\_\-wavelet\_\-num]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ int FrameTL::first\_\-wavelet\_\-num (const FRAME $\ast$ {\em frame}, \/  const int {\em j})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_d2a45d507a64c17ff1cf1edeb7afcd8e}


Number of first wavelet on level $j \geq j0$. \hypertarget{namespaceFrameTL_5338ae7f2ce93a8449560cc020fa212a}{
\index{FrameTL@{FrameTL}!GALERKIN@{GALERKIN}}
\index{GALERKIN@{GALERKIN}!FrameTL@{FrameTL}}
\subsubsection[GALERKIN]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::GALERKIN (const PROBLEM \& {\em P}, \/  const int {\em patch}, \/  const CDD1Parameters \& {\em params}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em F}, \/  const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em v}, \/  const double {\em delta}, \/  const double {\em eta}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em u\_\-bar}, \/  const int {\em jmax}, \/  const CompressionStrategy {\em strategy})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_5338ae7f2ce93a8449560cc020fa212a}


GALERKIN. 

Given an approximation v to the exact Galerkin solution u\_\-Lambda of Au = F w.r.t. the index set Lambda, such that $|$$|$u\_\-Lambda-v$|$$|$\_\-2 $<$= delta, and a target accuracy eta, compute an approximation u\_\-bar to u\_\-Lambda which is supported on Lambda and satisfies $|$$|$u\_\-bar-u\_\-Lambda$|$$|$\_\-2 $<$= eta. \hypertarget{namespaceFrameTL_3ce808a3f26fc1938139488a730e994d}{
\index{FrameTL@{FrameTL}!H\_\-1\_\-semi\_\-norm\_\-Lshaped@{H\_\-1\_\-semi\_\-norm\_\-Lshaped}}
\index{H\_\-1\_\-semi\_\-norm\_\-Lshaped@{H\_\-1\_\-semi\_\-norm\_\-Lshaped}!FrameTL@{FrameTL}}
\subsubsection[H\_\-1\_\-semi\_\-norm\_\-Lshaped]{\setlength{\rightskip}{0pt plus 5cm}double FrameTL::H\_\-1\_\-semi\_\-norm\_\-Lshaped (const Function$<$ 2 $>$ \& {\em gradient})}}
\label{namespaceFrameTL_3ce808a3f26fc1938139488a730e994d}


Computes an approximation to the $H^1$-norm of a function in the L-shaped domain $[-1,1]^2 \ [0,1)^2$. 

The parameter gradient is assumed to be the gradient of the function. \hypertarget{namespaceFrameTL_0699f5e7931ab40bf346b17e6c3bde01}{
\index{FrameTL@{FrameTL}!in\_\-support@{in\_\-support}}
\index{in\_\-support@{in\_\-support}!FrameTL@{FrameTL}}
\subsubsection[in\_\-support]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::in\_\-support (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const Point$<$ DIM\_\-m $>$ \& {\em p})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_0699f5e7931ab40bf346b17e6c3bde01}


Checks wether Point 'p' lies in the support of the wavelet frame element $\psi_\lambda$. \hypertarget{namespaceFrameTL_b442ddca04900a00608a3963348b15bb}{
\index{FrameTL@{FrameTL}!inner\_\-prod@{inner\_\-prod}}
\index{inner\_\-prod@{inner\_\-prod}!FrameTL@{FrameTL}}
\subsubsection[inner\_\-prod]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ const double FrameTL::inner\_\-prod (const Point$<$ DIM $>$ \& {\em p1}, \/  const Point$<$ DIM $>$ \& {\em p2})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_b442ddca04900a00608a3963348b15bb}


Checks whether p lies left of right of or on the line specified by the Points p1 and p2. This line is oriented by the vector starting in p1 and ending in p2. returning 0 means RIGHT OF LINE returning 1 means LEFT OF LINE returning 2 means ON LINE

computes l\_\-2 inner product will be placed in class Point in the future or replaced by appropriate function in class tensor \hypertarget{namespaceFrameTL_cd7462527bff134a7c142ee0471d6ab2}{
\index{FrameTL@{FrameTL}!INRESIDUAL@{INRESIDUAL}}
\index{INRESIDUAL@{INRESIDUAL}!FrameTL@{FrameTL}}
\subsubsection[INRESIDUAL]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::INRESIDUAL (const PROBLEM \& {\em P}, \/  const int {\em patch}, \/  const CDD1Parameters \& {\em params}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em F}, \/  const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em v}, \/  const double {\em eta1}, \/  const double {\em eta2}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em r}, \/  const int {\em jmax}, \/  const CompressionStrategy {\em strategy})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_cd7462527bff134a7c142ee0471d6ab2}


INRESIDUAL. 

Given an index set Lambda, an approximation v to the exact Galerkin solution u\_\-Lambda of Au = F, calculate an approximate INternal residual r, such that $|$$|$r - (A\_\-Lambda v - P\_\-Lambda f)$|$$|$\_\-2 $<$= eta\_\-1 + eta\_\-2 \hypertarget{namespaceFrameTL_27f6cca23b933ff76a0597a62f5dd870}{
\index{FrameTL@{FrameTL}!intersect\_\-singular\_\-support@{intersect\_\-singular\_\-support}}
\index{intersect\_\-singular\_\-support@{intersect\_\-singular\_\-support}!FrameTL@{FrameTL}}
\subsubsection[intersect\_\-singular\_\-support]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::intersect\_\-singular\_\-support (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em nu})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_27f6cca23b933ff76a0597a62f5dd870}


Decide whether the support of a given generator/wavelet $\psi_\lambda$ intersects the singular support of another generator/wavelet $\psi_\nu$. \hypertarget{namespaceFrameTL_0b6d3a80be9f0dd032527c3c17ce3f62}{
\index{FrameTL@{FrameTL}!intersect\_\-supports@{intersect\_\-supports}}
\index{intersect\_\-supports@{intersect\_\-supports}!FrameTL@{FrameTL}}
\subsubsection[intersect\_\-supports]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::intersect\_\-supports (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em mu}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-lambda})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_0b6d3a80be9f0dd032527c3c17ce3f62}


Checks wether the support of the wavelet frame elements intersect. \hypertarget{namespaceFrameTL_5aeecded043a910b0dae7228883304b3}{
\index{FrameTL@{FrameTL}!intersect\_\-supports@{intersect\_\-supports}}
\index{intersect\_\-supports@{intersect\_\-supports}!FrameTL@{FrameTL}}
\subsubsection[intersect\_\-supports]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::intersect\_\-supports (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em mu}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-lambda}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-mu}, \/  FixedArray1D$<$ Array1D$<$ double $>$, DIM\_\-d $>$ \& {\em supp\_\-intersect})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_5aeecded043a910b0dae7228883304b3}


THIS ROUTINE IS INTENDED FOR THE SPECIAL CASE OF TRIVIAL PARAMETRIZATIONS, NAMELY AFFINE LINEAR MAPPINGS 'A x + B' WITH 'A' BEEING A DIAGONAL MATRIX. The function checks whether two wavelets intersect and returns an irregular partition of the support intersection pulled back to the unit cube by the chart corresponding to $\psi_\lambda$. This is needed to be able to exactly compute the entries of the stiffness matrix for the above case of very simple patch parametrizations. \hypertarget{namespaceFrameTL_6d6670ec9613c9cf6ac3511a4b623429}{
\index{FrameTL@{FrameTL}!intersect\_\-supports@{intersect\_\-supports}}
\index{intersect\_\-supports@{intersect\_\-supports}!FrameTL@{FrameTL}}
\subsubsection[intersect\_\-supports]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::intersect\_\-supports (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em mu}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-lambda}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-mu})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_6d6670ec9613c9cf6ac3511a4b623429}


Checks wether the support of the wavelet frame elements $\psi_\lambda$ and $\psi_\mu$ intersect. The supports of the corresponding cube wavelets have to be passed as arguments supp\_\-lambda and supp\_\-mu. \hypertarget{namespaceFrameTL_02c30f3ec04242a2445af8e588bae6b2}{
\index{FrameTL@{FrameTL}!intersect\_\-supports\_\-1D@{intersect\_\-supports\_\-1D}}
\index{intersect\_\-supports\_\-1D@{intersect\_\-supports\_\-1D}!FrameTL@{FrameTL}}
\subsubsection[intersect\_\-supports\_\-1D]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::intersect\_\-supports\_\-1D (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const Index1D$<$ IBASIS $>$ \& {\em lambda}, \/  const Index1D$<$ IBASIS $>$ \& {\em mu}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-lambda}, \/  const typename CubeBasis$<$ IBASIS, DIM\_\-d $>$::Support $\ast$ {\em supp\_\-mu}, \/  const int {\em dir}, \/  Array1D$<$ double $>$ \& {\em supp\_\-intersect})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_02c30f3ec04242a2445af8e588bae6b2}


This function checks whether the supports of the two functions given by lambda and mu intersect. It also generates an irregular partition of the support intersection pulled back to the unit interval by the parametric mapping corresponding to lambda. \hypertarget{namespaceFrameTL_8008f4b3d0a7bb7acab2b74a29d60222}{
\index{FrameTL@{FrameTL}!intersect\_\-supports\_\-simple@{intersect\_\-supports\_\-simple}}
\index{intersect\_\-supports\_\-simple@{intersect\_\-supports\_\-simple}!FrameTL@{FrameTL}}
\subsubsection[intersect\_\-supports\_\-simple]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ bool FrameTL::intersect\_\-supports\_\-simple (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em mu})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_8008f4b3d0a7bb7acab2b74a29d60222}


Checks wether the support of the wavelet frame elements intersect. WE ASSUME THAT THE PATCHES ARE RECTANGULAR AND THAT THEY ARE ALIGNED WITH THE CARTESIAN GRID. \hypertarget{namespaceFrameTL_0005c53dfff8661290582ea77b5ebcff}{
\index{FrameTL@{FrameTL}!intersecting\_\-wavelets@{intersecting\_\-wavelets}}
\index{intersecting\_\-wavelets@{intersecting\_\-wavelets}!FrameTL@{FrameTL}}
\subsubsection[intersecting\_\-wavelets]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ void FrameTL::intersecting\_\-wavelets (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const int {\em p}, \/  const std::set$<$ typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \& {\em Lambda}, \/  std::list$<$ typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \& {\em intersecting})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_0005c53dfff8661290582ea77b5ebcff}


For a given wavelet frame element $\psi_\lambda$, compute all generators/wavelets from patch p in the set Lambda, the supports of which intersect the one of $\psi_\lambda$. WE ASSUME AGAIN THAT ONLY RECTANGULAR PATCHTES ALIGNED WITH THE COORDINATE AXES ARE USED. \hypertarget{namespaceFrameTL_1823fb7effb657b388e652efbef319b3}{
\index{FrameTL@{FrameTL}!intersecting\_\-wavelets@{intersecting\_\-wavelets}}
\index{intersecting\_\-wavelets@{intersecting\_\-wavelets}!FrameTL@{FrameTL}}
\subsubsection[intersecting\_\-wavelets]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ void FrameTL::intersecting\_\-wavelets (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const int {\em j}, \/  const bool {\em generators}, \/  std::list$<$ typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \& {\em intersecting})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_1823fb7effb657b388e652efbef319b3}


For a given wavelet frame element $\psi_\lambda$, compute all generators/wavelets $\psi_\nu$ with level $|\nu|=j$, such that the respective supports have a nontrivial intersection. \hypertarget{namespaceFrameTL_e57f8b33a1d5167ca7a23c7762e9ad1a}{
\index{FrameTL@{FrameTL}!intersecting\_\-wavelets\_\-on\_\-patch@{intersecting\_\-wavelets\_\-on\_\-patch}}
\index{intersecting\_\-wavelets\_\-on\_\-patch@{intersecting\_\-wavelets\_\-on\_\-patch}!FrameTL@{FrameTL}}
\subsubsection[intersecting\_\-wavelets\_\-on\_\-patch]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ void FrameTL::intersecting\_\-wavelets\_\-on\_\-patch (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \& {\em frame}, \/  const typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index \& {\em lambda}, \/  const int {\em p}, \/  const int {\em j}, \/  const bool {\em generators}, \/  std::list$<$ typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Index $>$ \& {\em intersecting})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_e57f8b33a1d5167ca7a23c7762e9ad1a}


For a given wavelet frame element $\psi_\lambda$, compute all generators/wavelets $\psi_\nu$ with level $|\nu|=j$ on patch p, such that the respective supports have a nontrivial intersection. WE ASSUME AGAIN THAT ONLY RECTANGULAR PATCHTES ALIGNED WITH THE COORDINATE AXES ARE USED. \hypertarget{namespaceFrameTL_a6650ac9337756c12f5022699c50cc28}{
\index{FrameTL@{FrameTL}!last\_\-generator@{last\_\-generator}}
\index{last\_\-generator@{last\_\-generator}!FrameTL@{FrameTL}}
\subsubsection[last\_\-generator]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ {\bf FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ FrameTL::last\_\-generator (const FRAME $\ast$ {\em frame}, \/  const int {\em j})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_a6650ac9337756c12f5022699c50cc28}


Index of last generator on level $j \geq j_0$. \hypertarget{namespaceFrameTL_0544af1a279910dc8bcdb9b542df3166}{
\index{FrameTL@{FrameTL}!last\_\-generator\_\-num@{last\_\-generator\_\-num}}
\index{last\_\-generator\_\-num@{last\_\-generator\_\-num}!FrameTL@{FrameTL}}
\subsubsection[last\_\-generator\_\-num]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ int FrameTL::last\_\-generator\_\-num (const FRAME $\ast$ {\em frame})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_0544af1a279910dc8bcdb9b542df3166}


Number of last generator on level $j_0$. \hypertarget{namespaceFrameTL_7c29f890e91e2cd966b9ac6b773277cf}{
\index{FrameTL@{FrameTL}!last\_\-wavelet@{last\_\-wavelet}}
\index{last\_\-wavelet@{last\_\-wavelet}!FrameTL@{FrameTL}}
\subsubsection[last\_\-wavelet]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ {\bf FrameIndex}$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ FrameTL::last\_\-wavelet (const FRAME $\ast$ {\em frame}, \/  const int {\em j})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_7c29f890e91e2cd966b9ac6b773277cf}


Index of last wavelet on level $j \geq j_0$. \hypertarget{namespaceFrameTL_98345f161b05ac9604fbd9070da0bba7}{
\index{FrameTL@{FrameTL}!last\_\-wavelet\_\-num@{last\_\-wavelet\_\-num}}
\index{last\_\-wavelet\_\-num@{last\_\-wavelet\_\-num}!FrameTL@{FrameTL}}
\subsubsection[last\_\-wavelet\_\-num]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m, class FRAME$>$ int FrameTL::last\_\-wavelet\_\-num (const FRAME $\ast$ {\em frame}, \/  const int {\em j})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_98345f161b05ac9604fbd9070da0bba7}


Index of last wavelet on level $j \geq j0$. \hypertarget{namespaceFrameTL_a6fc7f7f5f218c3dc3e34081b4e7464d}{
\index{FrameTL@{FrameTL}!MultSchw@{MultSchw}}
\index{MultSchw@{MultSchw}!FrameTL@{FrameTL}}
\subsubsection[MultSchw]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::MultSchw (const PROBLEM \& {\em P}, \/  const double {\em epsilon}, \/  Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \& {\em approximations})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_a6fc7f7f5f218c3dc3e34081b4e7464d}


Adaptive multiplicative Schwarz wavelet frame algorithm from Stevenson, Werner 2009. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em P}]The cached discrete problem. \item[{\em epsilon}]The target $\ell_2$-accuracy of the algorithm. \item[{\em approximations}]An array of length number of patches +1. We return in this array the local discrete approximations on each patch. The last entry contains the final global discrete approximation at termination. \end{description}
\end{Desc}
\hypertarget{namespaceFrameTL_f3d9112d64f468a664317686725617bd}{
\index{FrameTL@{FrameTL}!NGROW@{NGROW}}
\index{NGROW@{NGROW}!FrameTL@{FrameTL}}
\subsubsection[NGROW]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::NGROW (const PROBLEM \& {\em P}, \/  const int {\em patch}, \/  const CDD1Parameters \& {\em params}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em F}, \/  const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em u\_\-bar}, \/  const double {\em xi1}, \/  const double {\em xi2}, \/  set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda\_\-tilde}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em r}, \/  const int {\em jmax}, \/  const CompressionStrategy {\em strategy})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_f3d9112d64f468a664317686725617bd}


NGROW. 

Given a set Lambda, an initial approximation ubar (supported in Lambda) to the Galerkin solutin u\_\-Lambda of Au = F, calculate an approximate residual r with $|$$|$r-r\_\-Lambda$|$$|$\_\-2 $<$= xi\_\-1 + xi\_\-2 + c\_\-2 $\ast$ $|$$|$ubar-u\_\-Lambda$|$$|$\_\-2 and a new index set Lambda\_\-tilde Lambda as small as possible such that $|$$|$P\_\-\{Lambda\_\-tilde Lambda\}r$|$$|$\_\-2 $>$= gamma $\ast$ $|$$|$r$|$$|$\_\-2 \hypertarget{namespaceFrameTL_6fd34de92145c0f42b41f9b36a379e9f}{
\index{FrameTL@{FrameTL}!norm2@{norm2}}
\index{norm2@{norm2}!FrameTL@{FrameTL}}
\subsubsection[norm2]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ const double FrameTL::norm2 (Point$<$ DIM $>$ \& {\em p})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_6fd34de92145c0f42b41f9b36a379e9f}


computes l\_\-2 inner product will be placed in class Point in the future or replaced by appropriate function in class tensor \hypertarget{namespaceFrameTL_d25b2eb9873b17224cdc0ddc9b0d04b1}{
\index{FrameTL@{FrameTL}!NPROG@{NPROG}}
\index{NPROG@{NPROG}!FrameTL@{FrameTL}}
\subsubsection[NPROG]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::NPROG (const PROBLEM \& {\em P}, \/  const int {\em patch}, \/  const CDD1Parameters \& {\em params}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em F}, \/  const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em v}, \/  const double {\em delta}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em v\_\-hat}, \/  set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda\_\-hat}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em r\_\-hat}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em u\_\-Lambda\_\-k}, \/  const int {\em jmax}, \/  const CompressionStrategy {\em strategy})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_d25b2eb9873b17224cdc0ddc9b0d04b1}


NPROG. 

Given an approximation v (the support of which is contained in Lambda) to the exact Galerkin solution u of Au = F with $|$$|$u-v$|$$|$\_\-2 $<$= delta, compute a new approximation v\_\-hat supported in Lambda\_\-hat, such that $|$$|$u-v\_\-hat$|$$|$\_\-2 $<$= delta/2. An approximate residual r\_\-hat as well as the last iterand ubar before the final thresholding are also returned. \hypertarget{namespaceFrameTL_e86daf5e125e66504844e002ba3dc4b5}{
\index{FrameTL@{FrameTL}!NRESIDUAL@{NRESIDUAL}}
\index{NRESIDUAL@{NRESIDUAL}!FrameTL@{FrameTL}}
\subsubsection[NRESIDUAL]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::NRESIDUAL (const PROBLEM \& {\em P}, \/  const int {\em patch}, \/  const CDD1Parameters \& {\em params}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em F}, \/  const set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda}, \/  const InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em v}, \/  const double {\em eta1}, \/  const double {\em eta2}, \/  InfiniteVector$<$ double, typename PROBLEM::WaveletBasis::Index $>$ \& {\em r}, \/  set$<$ typename PROBLEM::WaveletBasis::Index $>$ \& {\em Lambda\_\-tilde}, \/  const int {\em jmax}, \/  const CompressionStrategy {\em strategy})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_e86daf5e125e66504844e002ba3dc4b5}


NRESIDUAL. 

Given an index set Lambda, an approximation v to the exact Galerkin solution u\_\-Lambda of Au = F, calculate an approximate residual r (not necessarily supported in J), such that $|$$|$r - r\_\-Lambda$|$$|$\_\-2 $<$= eta\_\-1 + eta\_\-2 + c\_\-2 $\ast$ $|$$|$v-u\_\-Lambda$|$$|$\_\-2 The routine also returns the support set Lambda\_\-tilde of the approximate residual r. \hypertarget{namespaceFrameTL_4f787a15e5a101207d222e0a799a7e5d}{
\index{FrameTL@{FrameTL}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!FrameTL@{FrameTL}}
\subsubsection[operator$<$$<$]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ std::ostream \& FrameTL::operator$<$$<$ (std::ostream \&, \/  const FrameIndex$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_4f787a15e5a101207d222e0a799a7e5d}


Stream output for \hyperlink{classFrameTL_1_1FrameIndex}{FrameIndex}. \hypertarget{namespaceFrameTL_218a9a8d5b69562375139a49043fce0b}{
\index{FrameTL@{FrameTL}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!FrameTL@{FrameTL}}
\subsubsection[operator$<$$<$]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ std::ostream\& FrameTL::operator$<$$<$ (std::ostream \&, \/  const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ \&)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_218a9a8d5b69562375139a49043fce0b}


stream output of an \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame} \hypertarget{namespaceFrameTL_d4045e5ba1e89e5fbdd9084024f16ae0}{
\index{FrameTL@{FrameTL}!pos\_\-wrt\_\-line@{pos\_\-wrt\_\-line}}
\index{pos\_\-wrt\_\-line@{pos\_\-wrt\_\-line}!FrameTL@{FrameTL}}
\subsubsection[pos\_\-wrt\_\-line]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ unsigned short int FrameTL::pos\_\-wrt\_\-line (const Point$<$ DIM $>$ \& {\em p}, \/  const Point$<$ DIM $>$ \& {\em p1}, \/  const Point$<$ DIM $>$ \& {\em p2})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_d4045e5ba1e89e5fbdd9084024f16ae0}


Checks whether p lies left of right of or on the line specified by the Points p1 and p2. This line's orientation is given by the vector starting in p1 and ending in p2. returning 0 means RIGHT OF LINE returning 1 means LEFT OF LINE returning 2 means ON LINE \hypertarget{namespaceFrameTL_d92777b6b7c3d1dc873761d9280ec994}{
\index{FrameTL@{FrameTL}!precompute\_\-supports\_\-simple@{precompute\_\-supports\_\-simple}}
\index{precompute\_\-supports\_\-simple@{precompute\_\-supports\_\-simple}!FrameTL@{FrameTL}}
\subsubsection[precompute\_\-supports\_\-simple]{\setlength{\rightskip}{0pt plus 5cm}template$<$class IBASIS, unsigned int DIM\_\-d, unsigned int DIM\_\-m$>$ void FrameTL::precompute\_\-supports\_\-simple (const AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$ $\ast$ {\em frame}, \/  Array1D$<$ typename AggregatedFrame$<$ IBASIS, DIM\_\-d, DIM\_\-m $>$::Support $>$ \& {\em all\_\-patch\_\-supports})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_d92777b6b7c3d1dc873761d9280ec994}


For the case of rectangular patches, the supports of all wavelets frame elements between minimal and maximal level are computed. This routine is supposed to be called during the initialization process of an \hyperlink{classFrameTL_1_1AggregatedFrame}{AggregatedFrame} in its constructor. \hypertarget{namespaceFrameTL_0f4762cff5b194a929e2eadddbfd0d71}{
\index{FrameTL@{FrameTL}!quadrangles\_\-intersect@{quadrangles\_\-intersect}}
\index{quadrangles\_\-intersect@{quadrangles\_\-intersect}!FrameTL@{FrameTL}}
\subsubsection[quadrangles\_\-intersect]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ bool FrameTL::quadrangles\_\-intersect (FixedArray1D$<$ Point$<$ DIM $>$, 4 $>$ {\em poly1}, \/  FixedArray1D$<$ Point$<$ DIM $>$, 4 $>$ {\em poly2})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_0f4762cff5b194a929e2eadddbfd0d71}


This function checks whether the convex qudrangles given by the vertices in poly1 and poly2 have a non-trivial intersection. \hypertarget{namespaceFrameTL_3ea47092508598512ecc54955117a16f}{
\index{FrameTL@{FrameTL}!receive\_\-all\_\-parts@{receive\_\-all\_\-parts}}
\index{receive\_\-all\_\-parts@{receive\_\-all\_\-parts}!FrameTL@{FrameTL}}
\subsubsection[receive\_\-all\_\-parts]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::receive\_\-all\_\-parts (const PROBLEM \&, \/  InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_3ea47092508598512ecc54955117a16f}


All processors, apart from the master, receive an InfiniteVector$<$double, typename PROBLEM::Index$>$. This routine is intended to work hand in hand with broadcast\_\-vec\_\-from\_\-Master. In a parallel adaptive Schwarz frame algorithm, the master broadcasts the new global discrete iterate in an InfiniteVector$<$double, typename PROBLEM::Index$>$ while the others are receiving this message with receive\_\-all\_\-parts. \hypertarget{namespaceFrameTL_868f995657a7f68345fe24340658282e}{
\index{FrameTL@{FrameTL}!send\_\-to\_\-Master@{send\_\-to\_\-Master}}
\index{send\_\-to\_\-Master@{send\_\-to\_\-Master}!FrameTL@{FrameTL}}
\subsubsection[send\_\-to\_\-Master]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::send\_\-to\_\-Master (const InfiniteVector$<$ double, typename PROBLEM::Index $>$ \&)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_868f995657a7f68345fe24340658282e}


This routine sends an InfiniteVector$<$double, typename PROBLEM::Index$>$ from the current processor to the mater (the one with pid 0). \hypertarget{namespaceFrameTL_010a7b97f26561b6923f285c1cbb8d02}{
\index{FrameTL@{FrameTL}!setup\_\-coefficient\_\-datatype@{setup\_\-coefficient\_\-datatype}}
\index{setup\_\-coefficient\_\-datatype@{setup\_\-coefficient\_\-datatype}!FrameTL@{FrameTL}}
\subsubsection[setup\_\-coefficient\_\-datatype]{\setlength{\rightskip}{0pt plus 5cm}void FrameTL::setup\_\-coefficient\_\-datatype ()}}
\label{namespaceFrameTL_010a7b97f26561b6923f285c1cbb8d02}


Create mpi datatype, consisting of an int and a double. Don't forget to call this routine at the very beginning of the mpi program. \hypertarget{namespaceFrameTL_c04ff1f80c162c3369928a2b45402beb}{
\index{FrameTL@{FrameTL}!simplified\_\-steepest\_\-descent\_\-SOLVE@{simplified\_\-steepest\_\-descent\_\-SOLVE}}
\index{simplified\_\-steepest\_\-descent\_\-SOLVE@{simplified\_\-steepest\_\-descent\_\-SOLVE}!FrameTL@{FrameTL}}
\subsubsection[simplified\_\-steepest\_\-descent\_\-SOLVE]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::simplified\_\-steepest\_\-descent\_\-SOLVE (const PROBLEM \& {\em problem}, \/  const double {\em epsilon}, \/  InfiniteVector$<$ double, typename PROBLEM::Index $>$ \& {\em u\_\-epsilon}, \/  const int {\em jmax})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_c04ff1f80c162c3369928a2b45402beb}


Implementation of a simplified steepest descent solver as described in \mbox{[}DRWFS\mbox{]} Simplified means that the appearing constants are \char`\"{}guessed\char`\"{} and not estimated as in above publication. That is, we have a standard steepest descent algorithm with APPLY and RHS instead of the normal matrix vector operations. The main iteration step is u := u + alpha $\ast$ (RHS\mbox{[}eta\mbox{]} - APPLY\mbox{[}eta, u\mbox{]}) with the acceleration parameter alpha = res$^\wedge$T res / (res$^\wedge$T APPLY\mbox{[}eta, res\mbox{]}) and the residual res = (RHS\mbox{[}eta\mbox{]} - APPLY\mbox{[}eta, u\mbox{]})

\mbox{[}DRWFS\mbox{]} Stephan Dahlke, Thorsten Raasch, Manuel Werner, Massimo Fornasier and Rob Stevenson Adaptive frame methods for elliptic operator equations: the steepest descent approach \hypertarget{namespaceFrameTL_b98b858d0561768f9494ac7f962a6857}{
\index{FrameTL@{FrameTL}!steepest\_\-descent\_\-SOLVE@{steepest\_\-descent\_\-SOLVE}}
\index{steepest\_\-descent\_\-SOLVE@{steepest\_\-descent\_\-SOLVE}!FrameTL@{FrameTL}}
\subsubsection[steepest\_\-descent\_\-SOLVE]{\setlength{\rightskip}{0pt plus 5cm}template$<$class PROBLEM$>$ void FrameTL::steepest\_\-descent\_\-SOLVE (const PROBLEM \& {\em P}, \/  const double {\em epsilon}, \/  Array1D$<$ InfiniteVector$<$ double, typename PROBLEM::Index $>$ $>$ \& {\em approximations})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_b98b858d0561768f9494ac7f962a6857}


Adaptive steepest descent wavelet frame algorithm from Dahlke, Fornasier, Raasch, Stevenson, Werner 2007. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em P}]The cached discrete problem. \item[{\em epsilon}]The target $\ell_2$-accuracy of the algorithm. \item[{\em approximations}]An array of length number of patches+1. We return in this array the local discrete approximations on each patch. The last entry contains the final global discrete approximation at termination. \end{description}
\end{Desc}
\hypertarget{namespaceFrameTL_ab03f9658bfef63434301affb3b5803a}{
\index{FrameTL@{FrameTL}!sub@{sub}}
\index{sub@{sub}!FrameTL@{FrameTL}}
\subsubsection[sub]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int DIM$>$ Point$<$DIM$>$ FrameTL::sub (const Point$<$ DIM $>$ \& {\em p}, \/  const Vector$<$ double $>$ \& {\em b})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{namespaceFrameTL_ab03f9658bfef63434301affb3b5803a}


difference between Point p, viewed as vector, and Vector b 